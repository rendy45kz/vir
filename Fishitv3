--==================================================
-- AEGISHUB CORE INIT (CLEAN VERSION)
--==================================================

local Sirenx = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/rendy45kz/vir/refs/heads/main/aegishub.lua"
))()

local Window = Sirenx:Window({
    Title   = "AegisHUB |",
    Footer  = "Fish It",
    Image   = "85286478652862",
    Color   = Color3.fromRGB(0, 150, 255),
    Theme   = 133682498103356,
    Version = 1,
})

--------------------------------------------------
-- SERVICES (SINGLE SOURCE OF TRUTH)
--------------------------------------------------
local svc = {
    Players     = game:GetService("Players"),
    RunService  = game:GetService("RunService"),
    HttpService = game:GetService("HttpService"),
    RS          = game:GetService("ReplicatedStorage"),
    VU          = game:GetService("VirtualUser"),
    VIM         = game:GetService("VirtualInputManager"),
    PG          = game:GetService("Players").LocalPlayer.PlayerGui,
    Camera      = workspace.CurrentCamera,
    GuiService  = game:GetService("GuiService"),
    CoreGui     = game:GetService("CoreGui"),
    Stats       = game:GetService("Stats"),
    TpService   = game:GetService("TeleportService"),
    Starter     = game:GetService("StarterPlayer"),
    UIS         = game:GetService("UserInputService"),
}

--------------------------------------------------
-- HTTP CHECK
--------------------------------------------------
_G.httpRequest =
    (syn and syn.request)
    or (http and http.request)
    or http_request
    or (fluxus and fluxus.request)
    or request

if not _G.httpRequest then
    return
end

--------------------------------------------------
-- PLAYER SHORTCUT
--------------------------------------------------
local player = svc.Players.LocalPlayer

local function getHRP()
    local char = player.Character or player.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

local function getHumanoid()
    local char = player.Character or player.CharacterAdded:Wait()
    return char:WaitForChild("Humanoid")
end

--------------------------------------------------
-- FILE SYSTEM FIX (VERY IMPORTANT)
--------------------------------------------------
local BaseFolder   = "AegisHub"
local PositionFile = BaseFolder .. "/Position.json"

if makefolder and not isfolder(BaseFolder) then
    makefolder(BaseFolder)
end

--------------------------------------------------
-- MERCHANT GUI (SAFE)
--------------------------------------------------
local gui = {}
local merchant = svc.PG:WaitForChild("Merchant", 10)

if merchant then
    gui = {
        Merchant        = merchant,
        MerchantRoot    = merchant.Main.Background,
        ItemsFrame      = merchant.Main.Background.Items.ScrollingFrame,
        RefreshMerchant = merchant.Main.Background.RefreshLabel,
    }
end

--------------------------------------------------
-- MODULES (ONLY USED ONES)
--------------------------------------------------
local mods = {
    Net                    = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
    Replion                = require(svc.RS.Packages.Replion),
    FishingController      = require(svc.RS.Controllers.FishingController),
    NotificationController = require(svc.RS.Controllers.NotificationController),
    AnimationController    = require(svc.RS.Controllers.AnimationController),
    CutsceneController     = require(svc.RS.Controllers.CutsceneController),
    ItemUtility            = require(svc.RS.Shared.ItemUtility),
    NotifierFish           = require(svc.RS.Controllers.TextNotificationController),
    InputControl           = require(svc.RS.Modules.InputControl),
    VFX                    = require(svc.RS.Controllers.VFXController),
}

--------------------------------------------------
-- API REMOTES
--------------------------------------------------
local api = {
    Events = {
        RECutscene                    = mods.Net["RE/ReplicateCutscene"],
        REStop                        = mods.Net["RE/StopCutscene"],
        REFav                         = mods.Net["RE/FavoriteItem"],
        REFavChg                      = mods.Net["RE/FavoriteStateChanged"],
        REFishDone                    = mods.Net["RE/FishingCompleted"],
        REFishGot                     = mods.Net["RE/FishCaught"],
        RENotify                      = mods.Net["RE/TextNotification"],
        REEquip                       = mods.Net["RE/EquipToolFromHotbar"],
        REEquipItem                   = mods.Net["RE/EquipItem"],
        UpdateOxygen                  = mods.Net["URE/UpdateOxygen"],
        REPlayFishEffect              = mods.Net["RE/PlayFishingEffect"],
        RETextEffect                  = mods.Net["RE/ReplicateTextEffect"],
        REEvReward                    = mods.Net["RE/ClaimEventReward"],
        Totem                         = mods.Net["RE/SpawnTotem"],
        REObtainedNewFishNotification = mods.Net["RE/ObtainedNewFishNotification"],
        FishingMinigameChanged        = mods.Net["RE/FishingMinigameChanged"],
        FishingStopped                = mods.Net["RE/FishingStopped"],
    },

    Functions = {
        Trade       = mods.Net["RF/InitiateTrade"],
        BuyRod      = mods.Net["RF/PurchaseFishingRod"],
        BuyBait     = mods.Net["RF/PurchaseBait"],
        BuyWeather  = mods.Net["RF/PurchaseWeatherEvent"],
        ChargeRod   = mods.Net["RF/ChargeFishingRod"],
        StartMini   = mods.Net["RF/RequestFishingMinigameStarted"],
        UpdateRadar = mods.Net["RF/UpdateFishingRadar"],
        Cancel      = mods.Net["RF/CancelFishingInputs"],
        Dialogue    = mods.Net["RF/SpecialDialogueEvent"],
        SellItem    = mods.Net["RF/SellItem"],
        SellAllItem = mods.Net["RF/SellAllItems"],
        AutoEnabled = mods.Net["RF/UpdateAutoFishingState"],
    }
}

--------------------------------------------------
-- STATE TABLE
--------------------------------------------------
local st = {
    player       = player,
    walk         = false,
    walkSpeed    = 16,
    infiniteJump = false,

    hideIdentity = false,
    hideNames    = "AegisHUB",
    hideLevels   = "---------",

    char         = player.Character or player.CharacterAdded:Wait(),
    vim          = svc.VIM,
    cam          = svc.Camera,

    autoFishing  = false,
    completeDelay = 0.7,

    teleport = {
        island = nil,
        event  = nil,
        player = nil,
    },

    shop = {
        weather     = {},
        autoWeather = false,
    },

    sell = {
        enabled      = false,
        caughtTarget = 100,
    },

    favorite = {
        auto      = false,
        names     = {},
        rarities  = {},
        mutations = {},
    },

    hide = {
        notifications = false,
        cutscenes     = false,
        animations    = false,
        vfx           = false,
    },

    perfection = {
        activated      = false,
        enabled        = false,
        autoByInstant  = false,
    }
}

--------------------------------------------------
-- FORCE EQUIP ROD
--------------------------------------------------
local ForceEquipRod = {
    Enabled  = false,
    RodSlot = 1,
    Cooldown = 0.6
}

--------------------------------------------------
-- RUNTIME STATES
--------------------------------------------------
local ConnectionWalkSpeed = nil
local antiAfkConnection  = nil
local oldRequestCharge   = nil

--------------------------------------------------
-- WALK ON WATER STATE
--------------------------------------------------
local isWalkOnWater = false
local waterPlatform = nil
local walkOnWaterConnection = nil

local PLATFORM_SIZE = Vector3.new(18, 1, 18)

--------------------------------------------------
-- ANTI DROWN
--------------------------------------------------
local AntiDrown = {
    Enabled = false,
    Hooked  = false
}


--==================================================
-- METATABLE HOOK (LOAD ONCE)
--==================================================
local rawmt = getrawmetatable(game)
if rawmt and not AntiDrown.Hooked then
    setreadonly(rawmt, false)

    local oldNamecall = rawmt.__namecall

    rawmt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()

        -- BLOCK OXYGEN UPDATE
        if AntiDrown.Enabled
            and method == "FireServer"
            and tostring(self) == "URE/UpdateOxygen"
        then
            return nil
        end

        return oldNamecall(self, ...)
    end)

    setreadonly(rawmt, true)
    AntiDrown.Hooked = true
end

--==================================================
-- CREATE PLATFORM (ONCE)
--==================================================
local function CreateWaterPlatform()
    local p = Instance.new("Part")
    p.Name = "WaterPlatform"
    p.Anchored = true
    p.CanCollide = true
    p.Transparency = 1
    p.Size = PLATFORM_SIZE
    p.CastShadow = false
    p.Parent = workspace
    return p
end

--==================================================
-- WALK ON WATER (FIXED & STABLE)
--==================================================

local function EnableWalkOnWater()
    if isWalkOnWater then return end
    isWalkOnWater = true

    if not waterPlatform then
        waterPlatform = CreateWaterPlatform()
    end

    if walkOnWaterConnection then
        walkOnWaterConnection:Disconnect()
    end

    walkOnWaterConnection = RunService.Stepped:Connect(function()
        if not isWalkOnWater then return end

        local char = LocalPlayer.Character
        if not char then return end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then return end

        -- RAYCAST ONLY TERRAIN (WATER)
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Include
        params.FilterDescendantsInstances = { workspace.Terrain }
        params.IgnoreWater = false

        local origin = hrp.Position + Vector3.new(0, 6, 0)
        local direction = Vector3.new(0, -120, 0)

        local result = workspace:Raycast(origin, direction, params)

        if result and result.Material == Enum.Material.Water then
            local waterY = result.Position.Y

            -- PLATFORM IKUT PLAYER (SEDIKIT DI BAWAH AIR)
            waterPlatform.Position = Vector3.new(
                hrp.Position.X,
                waterY - 0.3,
                hrp.Position.Z
            )

            -- JAGA PLAYER TIDAK TENGGELAM SAAT JALAN
            if hrp.Position.Y < waterY + 2 then
                if not UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    hrp.AssemblyLinearVelocity = Vector3.new(
                        hrp.AssemblyLinearVelocity.X,
                        0,
                        hrp.AssemblyLinearVelocity.Z
                    )

                    hrp.CFrame = CFrame.new(
                        hrp.Position.X,
                        waterY + 3,
                        hrp.Position.Z
                    )
                end
            end
        else
            -- JANGAN HILANGKAN PLATFORM, IKUTI PLAYER
            waterPlatform.Position = Vector3.new(
                hrp.Position.X,
                hrp.Position.Y - 6,
                hrp.Position.Z
            )
        end
    end)
end


--==================================================
-- DISABLE WALK ON WATER
--==================================================
local function DisableWalkOnWater()
    if not isWalkOnWater then return end
    isWalkOnWater = false

    if walkOnWaterConnection then
        walkOnWaterConnection:Disconnect()
        walkOnWaterConnection = nil
    end

    if waterPlatform then
        waterPlatform:Destroy()
        waterPlatform = nil
    end
end


-- TRACK UUID YANG SUDAH DIHITUNG
local countedFishUUID = {}

local function EnablePerfection()
    if st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(true)
    end)

    pcall(function()
        if not oldRequestCharge then
            oldRequestCharge = mods.FishingController.RequestChargeFishingRod
        end
        mods.FishingController.RequestChargeFishingRod = function()
            return nil
        end
    end)

    st.perfection.enabled = true
end

local function DisablePerfection()
    if not st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(false)
    end)

    pcall(function()
        if oldRequestCharge then
            mods.FishingController.RequestChargeFishingRod = oldRequestCharge
            oldRequestCharge = nil
        end
    end)

    st.perfection.enabled = false
end


st.player.CharacterAdded:Connect(function(char)
  st.char = char
end)

local repl = {
  Data = mods.Replion.Client:WaitReplion("Data"),
  Items = svc.RS:WaitForChild("Items"),
  Variants = svc.RS:WaitForChild("Variants"),
  PlayerStat = require(svc.RS.Packages._Index:FindFirstChild("ytrev_replion@2.0.0-rc.3").replion)
}

local lastAntiAfk = 0

player.Idled:Connect(function()
    local now = os.clock()
    if now - lastAntiAfk < 30 then return end -- max tiap 30 detik
    lastAntiAfk = now

    svc.VU:CaptureController()
    svc.VU:ClickButton2(Vector2.zero)
end)


local Tabs = {
  Info = Window:AddTab({ Name = "Info", Icon = "player" }),
  Player = Window:AddTab({ Name = "Player", Icon = "user" }),
  Fishing = Window:AddTab({ Name = "Fishing", Icon = "fish" }),
  Shop = Window:AddTab({ Name = "Shop", Icon = "shop" }),
  Automation = Window:AddTab({ Name = "Automation", Icon = "next" }),
  Teleport = Window:AddTab({ Name = "Teleport", Icon = "gps" }),
  Misc = Window:AddTab({ Name = "Misc", Icon = "settings" }),
}

InfoSection = Tabs.Info:AddSection("Information", true)

InfoSection:AddParagraph({
  Title = "Join Whatsapp Server",
  Content = "Join Us!",
  Icon = "whatsapp",
  ButtonText = "Copy Whatsapp Link",
  ButtonCallback = function()
    local link = "https://chat.whatsapp.com/DU81SA1xaoiA5nOvxAr5OR"
    if setclipboard then
      setclipboard(link)
      sirenx("Successfully Copied!")
    end
  end
})

ServerSection = Tabs.Info:AddSection("Server")

local CurrentServer = ServerSection:AddParagraph({
  Title = "Current Server",
  Content = [[
Ping: 0 ms | FPS: 0/s | Players: 0/0
  ]],
  Icon = "stat",
})

local lastServerUpdate = 0
svc.RunService.Heartbeat:Connect(function(dt)
  lastServerUpdate += dt
  if lastServerUpdate < 1 then return end
  lastServerUpdate = 0

  CurrentServer:SetContent(
    string.format([[
Ping: %d ms | FPS: %d/s | Players: %d/%d
    ]],
      math.floor(svc.Stats.PerformanceStats.Ping:GetValue() + 0.5),
      math.floor(svc.Stats.Workspace.FPS:GetValue() + 0.5),
      #svc.Players:GetPlayers(),
      svc.Players.MaxPlayers
    )
  )
end)


ServerSection:AddButton({
  Title = "Rejoin Server",
  Content = "Rejoins the current server",
  Callback = function()
    sirenx("Rejoining Server...")
    svc.TpService:Teleport(game.PlaceId, player)
  end
})

Plyrs = Tabs.Player:AddSection("Player")

Plyrs:AddToggle({
  Title = "Enable",
  Content = "Enable Walk Speed Changer",
  Default = false,
  Callback = function(state)
    st.walk = state

    if ConnectionWalkSpeed then
      ConnectionWalkSpeed:Disconnect()
      ConnectionWalkSpeed = nil
    end

    if state then
      local hum = getHumanoid()
      hum.WalkSpeed = st.walkSpeed
      ConnectionWalkSpeed = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if st.walk and hum.WalkSpeed ~= st.walkSpeed then
          hum.WalkSpeed = st.walkSpeed
        end
      end)
    else
      getHumanoid().WalkSpeed = svc.Starter.CharacterWalkSpeed
    end
  end
})

Plyrs:AddSlider({
  Title = "Walk Speed",
  Content = "Change your walk speed",
  Min = 16,
  Max = 500,
  Increment = 1,
  Default = st.walkSpeed,
  Callback = function(value)
    st.walkSpeed = value
    if st.walk then
      getHumanoid().WalkSpeed = value
    end
  end
})

Plyrs:AddToggle({
  Title = "Walk on Water",
  Content = "Allows you to walk on water",
  Default = false,
  Callback = function(state)
    if state then
      EnableWalkOnWater()
    else
      DisableWalkOnWater()
    end
  end
})


Plyrs:AddToggle({
    Title = "Anti Drown (Bypass)",
    Content = "Block oxygen update (no drowning)",
    Default = false,
    Callback = function(state)
        AntiDrown.Enabled = state
    end
})

local InfiniteJumpConnection

Plyrs:AddToggle({
  Title = "Infinite Jump",
  Content = "Allows you to jump infinitely",
  Default = false,
  Callback = function(state)
    st.infiniteJump = state

    if InfiniteJumpConnection then
      InfiniteJumpConnection:Disconnect()
      InfiniteJumpConnection = nil
    end

    if state then
      InfiniteJumpConnection = svc.UIS.JumpRequest:Connect(function()
        if st.infiniteJump then
          local hum = getHumanoid()
          if hum then
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
          end
        end
      end)
    end
  end
})


--------------------------------------------------------
-- HIDE IDENTITY (FIXED & WORKING)
--------------------------------------------------------

local Connections = {}
local OriginalText = {}
local DescendantAddedConnection

local function SafeText(obj)
    local ok, txt = pcall(function()
        return obj.Text
    end)
    return ok and type(txt) == "string" and txt or nil
end

local function HandleUsernameChange(Object)
    if not st.hideIdentity then return end
    if not (Object:IsA("TextLabel") or Object:IsA("TextBox") or Object:IsA("TextButton")) then
        return
    end

    local text = SafeText(Object)
    if not text then return end

    if not Connections[Object] then
        Connections[Object] = Object:GetPropertyChangedSignal("Text"):Connect(function()
            HandleUsernameChange(Object)
        end)
    end

    if text:find(st.player.Name, 1, true)
        or text:find(st.player.DisplayName, 1, true)
    then
        OriginalText[Object] = OriginalText[Object] or text
        Object.Text = text
            :gsub(st.player.Name, st.hideNames)
            :gsub(st.player.DisplayName, st.hideNames)
    end
end

--------------------------------------------------------
-- TOGGLE
--------------------------------------------------------
Plyrs:AddToggle({
    Title = "Hide Identity",
    Content = "Hides your player identity locally",
    Default = false,
    Callback = function(state)
        st.hideIdentity = state

        -- CLEAN OLD
        if DescendantAddedConnection then
            DescendantAddedConnection:Disconnect()
            DescendantAddedConnection = nil
        end

        for _, conn in pairs(Connections) do
            if conn then conn:Disconnect() end
        end
        Connections = {}

        -- RESTORE TEXT
        for obj, text in pairs(OriginalText) do
            if obj and obj.Parent then
                pcall(function()
                    obj.Text = text
                end)
            end
        end
        OriginalText = {}

        if not state then return end

        -- INITIAL SCAN (BATCH, NO FREEZE)
        task.spawn(function()
            local count = 0
            for _, v in ipairs(game:GetDescendants()) do
                HandleUsernameChange(v)
                count += 1
                if count % 150 == 0 then
                    task.wait()
                end
            end
        end)

        -- NEW UI
        DescendantAddedConnection = game.DescendantAdded:Connect(function(v)
            HandleUsernameChange(v)
        end)
    end
})


local Camera = Tabs.Player:AddSection("Camera")

Camera:AddToggle({
  Title = "Max Zoom",
  Content = "Allows you to zoom out the furthest",
  Default = false,
  Callback = function(state)
    ConnectionZoom = ConnectionZoom or nil

    if ConnectionZoom then
      ConnectionZoom:Disconnect()
      ConnectionZoom = nil
    end

    if state then
      st.player.CameraMaxZoomDistance = 50000
      ConnectionZoom = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
        if st.player.CameraMaxZoomDistance ~= 50000 then
          st.player.CameraMaxZoomDistance = 50000
        end
      end)
    else
      st.player.CameraMaxZoomDistance = svc.Starter.CameraMaxZoomDistance
    end
  end
})

--//======================================================
--// FISHING (INSTANT / BLATANT / ULTRA) - CPU SAFE FIX
--//======================================================

--------------------------------------------------------
-- INSTANT FISHING (EVENT-BASED, GUARDED)
--------------------------------------------------------
local AutoFishing = Tabs.Fishing:AddSection("Instant Fishing")

local lastTextTrigger = 0

api.Events.RETextEffect.OnClientEvent:Connect(function(data)
    if not st.autoFishing then return end
    if not (data and data.TextData and data.TextData.EffectType == "Exclaim") then return end
    if not (st.char and data.Container == st.char:FindFirstChild("Head")) then return end

    local now = os.clock()
    if now - lastTextTrigger < 0.15 then return end -- throttle
    lastTextTrigger = now

    task.delay(st.completeDelay, function()
        if st.autoFishing then
            pcall(api.Events.REFishDone.FireServer, api.Events.REFishDone)
        end
    end)
end)

local InstantThread = nil

AutoFishing:AddToggle({
    Title = "Instant Fishing",
    Content = "Automatically fishes for you",
    Default = false,
    Callback = function(state)
        st.autoFishing = state

        if InstantThread then
            task.cancel(InstantThread)
            InstantThread = nil
        end

        api.Functions.AutoEnabled:InvokeServer(state)

        if state then
            InstantThread = task.spawn(function()
                while st.autoFishing do
                    api.Functions.ChargeRod:InvokeServer()
                    api.Functions.StartMini:InvokeServer(
                        -1,
                        0.999,
                        workspace:GetServerTimeNow()
                    )
                    task.wait(0.55) -- fixed delay (no spam)
                end
            end)
        end
    end
})

AutoFishing:AddInput({
    Title = "Complete Delay",
    Content = "Delay for complete fishing",
    Default = tostring(st.completeDelay),
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 0 and num <= 5 then
            st.completeDelay = num
        end
    end
})

--==================================================
--==================================================
-- BLATANT FISHING (PURE TASK.SPAWN - FAST)
--==================================================

--==================================================
-- ROD ANIMATION BYPASS CORE (LOAD ONCE)
--==================================================

local RodAnimBypass = {
    Enabled = false,
    Hooked = false
}

local function IsRodAnim(anim)
    if not anim then return false end
    local id = tostring(anim.AnimationId or ""):lower()
    return id:find("fish") or id:find("rod") or id:find("reel")
end

pcall(function()
    if RodAnimBypass.Hooked then return end
    RodAnimBypass.Hooked = true

    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    local old = mt.__namecall

    mt.__namecall = newcclosure(function(self, ...)
        local m = getnamecallmethod()
        if RodAnimBypass.Enabled and (m == "LoadAnimation" or m == "Play") then
            local anim = ...
            if IsRodAnim(anim) then
                return nil -- BLOCK rod animation
            end
        end
        return old(self, ...)
    end)
    setreadonly(mt, true)
end)

local function StopRodTracks(char)
    for _, tr in ipairs(char:GetDescendants()) do
        if tr:IsA("AnimationTrack") then
            local a = tr.Animation
            if IsRodAnim(a) then
                pcall(function()
                    tr:Stop()
                    tr:Destroy()
                end)
            end
        end
    end
end

player.CharacterAdded:Connect(function(c)
    task.wait(0.3)
    if RodAnimBypass.Enabled then
        StopRodTracks(c)
    end
end)


_G.FBlatant = _G.FBlatant or false
_G.Reel = _G.Reel or 1.9
_G.FishingDelay = _G.FishingDelay or 0.9

local function Fastest()
    task.spawn(function()
        local t = workspace:GetServerTimeNow()

        -- cancel dulu (biar reset state server)
        pcall(function()
            api.Functions.Cancel:InvokeServer()
        end)

        -- micro align (Â±1 frame)
        task.wait(0.03)

        pcall(function()
            api.Functions.ChargeRod:InvokeServer(t)
        end)

        -- sinkronisasi window server (INI KUNCI)
        local align = 0.045 + ((t * 1000) % 12) * 0.001
        task.wait(align)

        pcall(function()
            api.Functions.StartMini:InvokeServer(
                -1.233184814453125,
                0.994503488563327303,
                t
            )
        end)

        -- delay ini JANGAN 0, harus masuk completion window
        task.wait(_G.FishingDelay - 0.08)

        pcall(function()
            api.Events.REFishDone:FireServer()
        end)
    end)
end


--------------------------------------------------
-- GUI
--------------------------------------------------
local Fish2 = Tabs.Fishing:AddSection("Blatant Fishing")

Fish2:AddToggle({
    Title = "Blatant Fishing",
    Default = false,
    Callback = function(state)
        _G.FBlatant = state
        api.Functions.AutoEnabled:InvokeServer(state)

        if state then
            -- ðŸ”¥ AUTO BYPASS ANIM
            RodAnimBypass.Enabled = true
            StopRodTracks(player.Character)

            st.perfection.autoByInstant = true
            EnablePerfection()

            task.spawn(function()
                while _G.FBlatant do
                    Fastest()
                    task.wait(_G.Reel)
                end
            end)
        else
            -- ðŸ” RESTORE
            RodAnimBypass.Enabled = false

            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})


Fish2:AddInput({
    Title = "Delay Reel",
    Default = tostring(_G.Reel),
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            _G.Reel = n
        end
    end
})

Fish2:AddInput({
    Title = "Delay Fishing",
    Default = tostring(_G.FishingDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            _G.FishingDelay = n
        end
    end
})

local UltraBlatant = {
    Active = false,
    CompleteDelay = 0.18, -- ðŸ”¥ tuned
    CancelDelay = 0.06,   -- ðŸ”¥ tuned
    Thread = nil
}

-- SAFE CALL (ANDROID FRIENDLY)
local function SafeCall(fn)
    task.spawn(function()
        pcall(fn)
    end)
end

-- ULTRA CAST (TUNED, SAME FLOW)
local function UltraCast()
    local t = workspace:GetServerTimeNow()

    SafeCall(function()
        api.Functions.ChargeRod:InvokeServer(t)
    end)

    task.wait() -- 1 frame (WAJIB, jangan dihapus)

    SafeCall(function()
        api.Functions.StartMini:InvokeServer(
            -1.233184814453125,
            0.994503488563327303,
            t
        )
    end)
end

-- ULTRA LOOP (TUNED)
local function UltraLoop()
    while UltraBlatant.Active do
        UltraCast()

        task.wait(UltraBlatant.CompleteDelay)

        if UltraBlatant.Active then
            SafeCall(function()
                api.Events.REFishDone:FireServer()
            end)
        end

        task.wait(UltraBlatant.CancelDelay)

        if UltraBlatant.Active then
            SafeCall(function()
                api.Functions.Cancel:InvokeServer()
            end)
        end

        task.wait() -- ðŸ”’ micro yield anti freeze
    end
end


--------------------------------------------------
-- GUI
--------------------------------------------------
--======================================================
-- BLATANT BETA TAB (SAFE)
--======================================================

local UltraSection = Tabs.Fishing:AddSection("Blatant BETA")

UltraSection:AddToggle({
    Title = "Ultra Blatant Fishing",
    Content = "Extremely fast & aggressive fishing",
    Default = false,
    Callback = function(state)
        if state == UltraBlatant.Active then return end -- ðŸ”’ anti double toggle

        UltraBlatant.Active = state

        if state then
            st.perfection.autoByInstant = true
            EnablePerfection()

            SafeCall(function()
                api.Events.REEquip:FireServer(1)
            end)

            task.wait(0.1)

            if UltraBlatant.Thread then
                task.cancel(UltraBlatant.Thread)
            end

            UltraBlatant.Thread = task.spawn(UltraLoop)
        else
            UltraBlatant.Active = false

            if UltraBlatant.Thread then
                task.cancel(UltraBlatant.Thread)
                UltraBlatant.Thread = nil
            end

            SafeCall(function()
                api.Functions.Cancel:InvokeServer()
            end)

            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})

UltraSection:AddInput({
    Title = "Complete Delay",
    Default = tostring(UltraBlatant.CompleteDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n then
            UltraBlatant.CompleteDelay = math.clamp(n, 0.05, 1)
        end
    end
})

UltraSection:AddInput({
    Title = "Cancel Delay",
    Default = tostring(UltraBlatant.CancelDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n then
            UltraBlatant.CancelDelay = math.clamp(n, 0.02, 0.5)
        end
    end
})

--------------------------------------------------------
-- AUTO EQUIP ROD (FIXED LOOP)
--------------------------------------------------------

local EquipConn = nil
local lastEquip = 0

local function IsRodEquipped()
    local char = LocalPlayer.Character
    if not char then return false end

    for _, obj in ipairs(char:GetChildren()) do
        if obj:IsA("Tool") then
            return true
        end
    end
    return false
end

local function StartAutoEquip()
    if EquipConn then return end -- anti double loop

    lastEquip = 0

    EquipConn = svc.RunService.Heartbeat:Connect(function()
        if not ForceEquipRod.Enabled then return end

        local now = os.clock()
        if now - lastEquip < ForceEquipRod.Cooldown then return end

        local char = LocalPlayer.Character
        if not char then return end

        if IsRodEquipped() then return end

        lastEquip = now
        pcall(function()
            api.Events.REEquip:FireServer(ForceEquipRod.RodSlot or 1)
        end)
    end)
end

local function StopAutoEquip()
    if EquipConn then
        EquipConn:Disconnect()
        EquipConn = nil
    end
end


--------------------------------------------------------
-- PERFECTION SUPPORT (SAFE)
--------------------------------------------------------
local FishFeature = Tabs.Fishing:AddSection("Fishing Features")

FishFeature:AddToggle({
    Title = "Perfection Support",
    Default = true,
    Callback = function(state)
        st.perfection.activated = state
        if state then
            EnablePerfection()
        else
            if not st.perfection.autoByInstant then
                DisablePerfection()
            end
        end
    end
})

FishFeature:AddToggle({
    Title = "Auto Equip Rod",
    Content = "Force equip fishing rod (loop)",
    Default = false,
    Callback = function(state)
        ForceEquipRod.Enabled = state

        if state then
            StartAutoEquip()
        else
            StopAutoEquip()
        end
    end
})


FishFeature:AddButton({
    Title = "Recovery Fishing",
    Callback = function()
        pcall(function()
            api.Functions.Cancel:InvokeServer()
        end)
        player:SetAttribute("Loading", nil)
        task.wait(0.05)
        player:SetAttribute("Loading", false)
    end
})

--//======================================================
--// AUTO SELLING (CPU SAFE FIX)
--//======================================================

local SellGroup = Tabs.Fishing:AddSection("Auto Selling")

--------------------------------------------------------
-- INTERNAL STATE (GUARDED)
--------------------------------------------------------
local autoSellCount = 0
local autoSellCooldown = false
local countedFishUUID = {}
local lastSellEvent = 0
local sellingTaskRunning = false

local MAX_UUID_CACHE = 300 -- batas aman (hindari table membengkak)
local EVENT_THROTTLE = 0.05

--------------------------------------------------------
-- AUTO SELL HANDLER (THROTTLED)
--------------------------------------------------------
api.Events.REObtainedNewFishNotification.OnClientEvent:Connect(function(itemId, _, info)
    if not st.sell.enabled then return end
    if autoSellCooldown then return end
    if not info or not info.InventoryItem then return end

    local now = os.clock()
    if now - lastSellEvent < EVENT_THROTTLE then return end
    lastSellEvent = now

    local uuid = info.InventoryItem.UUID
    if not uuid then return end

    -- cegah double count
    if countedFishUUID[uuid] then return end
    countedFishUUID[uuid] = true
    autoSellCount += 1

    -- jaga ukuran table
    if autoSellCount > MAX_UUID_CACHE then
        autoSellCount = 0
        table.clear(countedFishUUID)
    end

    local target = tonumber(st.sell.caughtTarget) or 0
    if target <= 0 then return end

    if autoSellCount >= target and not sellingTaskRunning then
        sellingTaskRunning = true
        autoSellCooldown = true

        task.spawn(function()
            pcall(function()
                api.Functions.SellAllItem:InvokeServer()
            end)

            -- reset state
            autoSellCount = 0
            table.clear(countedFishUUID)

            task.wait(1.5)
            autoSellCooldown = false
            sellingTaskRunning = false
        end)
    end
end)

--------------------------------------------------------
-- GUI INPUT
--------------------------------------------------------
SellGroup:AddInput({
    Title = "Sell When Caught â‰¥",
    Content = "Auto sell after catching X fish",
    Default = tostring(st.sell.caughtTarget),
    Numeric = true,
    Callback = function(v)
        local n = tonumber(v)
        st.sell.caughtTarget = n or 0
    end
})

--------------------------------------------------------
-- TOGGLE
--------------------------------------------------------
SellGroup:AddToggle({
    Title = "Auto Sell by Fish Caught",
    Content = "Sell after catching X fish",
    Default = false,
    Callback = function(state)
        st.sell.enabled = state

        autoSellCount = 0
        autoSellCooldown = false
        sellingTaskRunning = false
        table.clear(countedFishUUID)
    end
})

--------------------------------------------------------
-- MANUAL BUTTON (SAFE)
--------------------------------------------------------
SellGroup:AddButton({
    Title = "Sell All Now",
    Content = "Immediately sell all fish in inventory",
    Callback = function()
        pcall(function()
            api.Functions.SellAllItem:InvokeServer()
        end)
    end
})

--//======================================================
--// FAVORITES (CPU SAFE FIX)
--//======================================================

local Favorites = Tabs.Fishing:AddSection("Favorites")

--------------------------------------------------------
-- RARITY MAP
--------------------------------------------------------
local TierToRarity = {
    [1] = "Common",
    [2] = "Uncommon",
    [3] = "Rare",
    [4] = "Epic",
    [5] = "Legendary",
    [6] = "Mythic",
    [7] = "Secret"
}

--------------------------------------------------------
-- FILTER CACHE (UPDATED ONLY ON CHANGE)
--------------------------------------------------------
local favoriteFilter = {
    names = {},
    rarities = {},
    mutations = {}
}

local function RebuildFavoriteFilter()
    table.clear(favoriteFilter.names)
    table.clear(favoriteFilter.rarities)
    table.clear(favoriteFilter.mutations)

    for _, n in ipairs(st.favorite.names or {}) do
        favoriteFilter.names[tostring(n)] = true
    end
    for _, r in ipairs(st.favorite.rarities or {}) do
        favoriteFilter.rarities[tostring(r)] = true
    end
    for _, m in ipairs(st.favorite.mutations or {}) do
        favoriteFilter.mutations[tostring(m)] = true
    end
end

--------------------------------------------------------
-- FAVORITE SINGLE ITEM CHECK
--------------------------------------------------------
local function ShouldFavoriteItem(Item)
    if Item.Favorited then return false end

    local FishData = mods.ItemUtility:GetItemData(Item.Id)
    if not FishData or not FishData.Data then return false end

    local data = FishData.Data
    local rarity = TierToRarity[data.Tier]
    local name = tostring(data.Name)
    local mutId = Item.Metadata and Item.Metadata.VariantId

    return
        (rarity and favoriteFilter.rarities[rarity]) or
        favoriteFilter.names[name] or
        (mutId and favoriteFilter.mutations[mutId])
end

--------------------------------------------------------
-- FAVORITE QUEUE (NO SPAWN FLOOD)
--------------------------------------------------------
local favoriteQueue = {}
local favoriteRunning = false

local function ProcessFavoriteQueue()
    if favoriteRunning then return end
    favoriteRunning = true

    while #favoriteQueue > 0 do
        local uuid = table.remove(favoriteQueue, 1)
        pcall(function()
            api.Events.REFav:FireServer(uuid)
        end)
        task.wait(0.01) -- smooth & safe
    end

    favoriteRunning = false
end

--------------------------------------------------------
-- EVENT-BASED AUTO FAVORITE (FIXED)
--------------------------------------------------------
api.Events.REObtainedNewFishNotification.OnClientEvent:Connect(function(_, _, info)
    if not st.favorite.auto then return end
    if not info or not info.InventoryItem then return end

    local Item = info.InventoryItem
    if not Item.UUID then return end

    if ShouldFavoriteItem(Item) then
        table.insert(favoriteQueue, Item.UUID)
        ProcessFavoriteQueue()
    end
end)

--------------------------------------------------------
-- UNFAVORITE ALL (SAFE)
--------------------------------------------------------
local function UnAutoFavoriteAll()
    local items = repl.Data.Data.Inventory.Items
    if not items then return end

    for _, Item in pairs(items) do
        if Item.Favorited then
            pcall(function()
                api.Events.REFav:FireServer(Item.UUID)
            end)
            task.wait(0.05)
        end
    end
end

--------------------------------------------------------
-- DROPDOWNS (CACHE SAFE)
--------------------------------------------------------
Favorites:AddDropdown({
    Title = "Auto Favorite by Rarity",
    Multi = true,
    Options = {"Common","Uncommon","Rare","Epic","Legendary","Mythic","Secret"},
    Default = st.favorite.rarities,
    Callback = function(v)
        st.favorite.rarities = v
        RebuildFavoriteFilter()
    end
})

local cachedFishNames
local function GetFishNames()
    if cachedFishNames then return cachedFishNames end
    cachedFishNames = {}

    for _, Item in pairs(repl.Items:GetChildren()) do
        local FishData = mods.ItemUtility:GetItemData(Item.Name)
        if FishData and FishData.Data and FishData.Data.Type == "Fish" then
            table.insert(cachedFishNames, FishData.Data.Name)
        end
    end
    return cachedFishNames
end

Favorites:AddDropdown({
    Title = "Auto Favorite by Name",
    Multi = true,
    Options = GetFishNames(),
    Default = st.favorite.names,
    Callback = function(v)
        st.favorite.names = v
        RebuildFavoriteFilter()
    end
})

local cachedMutations
local function GetFishMutation()
    if cachedMutations then return cachedMutations end
    cachedMutations = {}

    for _, v in pairs(repl.Variants:GetChildren()) do
        table.insert(cachedMutations, v.Name)
    end
    return cachedMutations
end

Favorites:AddDropdown({
    Title = "Auto Favorite by Mutation",
    Multi = true,
    Options = GetFishMutation(),
    Default = st.favorite.mutations,
    Callback = function(v)
        st.favorite.mutations = v
        RebuildFavoriteFilter()
    end
})

--------------------------------------------------------
-- TOGGLE
--------------------------------------------------------
Favorites:AddToggle({
    Title = "Auto Favorite",
    Content = "Automatically favorites fish",
    Default = false,
    Callback = function(state)
        st.favorite.auto = state
        if state then
            RebuildFavoriteFilter()
        end
    end
})

Favorites:AddButton({
    Title = "Unfavorite All",
    Callback = UnAutoFavoriteAll
})

--//======================================================
--// HIDE FEATURES (CPU SAFE FIX)
--//======================================================

local HideFeature = Tabs.Misc:AddSection("Hide Features")

--------------------------------------------------------
-- ANTI AFK (THROTTLED, NO SPAM)
--------------------------------------------------------
local VirtualUser = game:GetService("VirtualUser")
local lastAntiAfk = 0

HideFeature:AddToggle({
    Title = "Anti AFK",
    Content = "Prevents you from being kicked for idling",
    Default = true,
    Callback = function(state)
        if antiAfkConnection then
            antiAfkConnection:Disconnect()
            antiAfkConnection = nil
        end

        if state then
            antiAfkConnection = player.Idled:Connect(function()
                local now = os.clock()
                if now - lastAntiAfk < 30 then return end -- throttle 30s
                lastAntiAfk = now

                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        end
    end
})

--------------------------------------------------------
-- HIDE NOTIFICATION (SAFE HOOK, LOAD ONCE)
--------------------------------------------------------
pcall(function()
    if not mods.NotificationController then return end
    if mods.NotificationController._AegisNotifHooked then return end
    mods.NotificationController._AegisNotifHooked = true

    local OriginalNotif = mods.NotificationController.PlaySmallItemObtained
    mods.NotificationController._AegisOriginalNotif = OriginalNotif

    mods.NotificationController.PlaySmallItemObtained = function(self, ...)
        if st.hide.notifications then
            return
        end
        return OriginalNotif(self, ...)
    end
end)

HideFeature:AddToggle({
    Title = "Hide Notification",
    Content = "Hides fishing item notifications",
    Default = false,
    Callback = function(state)
        st.hide.notifications = state
    end
}, "HideNotification")

--------------------------------------------------------
-- SKIP CUTSCENES (SAFE INIT HOOK)
--------------------------------------------------------
pcall(function()
    if not mods.CutsceneController then return end
    if mods.CutsceneController._AegisHooked then return end
    mods.CutsceneController._AegisHooked = true

    mods.CutsceneController._OriginalInit =
        mods.CutsceneController._OriginalInit
        or mods.CutsceneController.Init

    mods.CutsceneController.Init = function(self, ...)
        if st.hide.cutscenes then
            return
        end
        return mods.CutsceneController._OriginalInit(self, ...)
    end
end)

HideFeature:AddToggle({
    Title = "Skip Cutscenes",
    Content = "Automatically skips fishing cutscenes",
    Default = false,
    Callback = function(state)
        st.hide.cutscenes = state
    end
}, "HideCutscenes")

--------------------------------------------------------
-- DISABLE ANIMATIONS (SAFE HOOK)
--------------------------------------------------------
pcall(function()
    if not mods.AnimationController then return end
    if mods.AnimationController._AegisAnimHooked then return end
    mods.AnimationController._AegisAnimHooked = true

    local OriginalAnim = mods.AnimationController.PlayAnimation
    mods.AnimationController._AegisOriginalAnim = OriginalAnim

    mods.AnimationController.PlayAnimation = function(self, ...)
        if st.hide.animations then
            return
        end
        return OriginalAnim(self, ...)
    end
end)

HideFeature:AddToggle({
    Title = "Disable Animations",
    Content = "Disables fishing animations",
    Default = false,
    Callback = function(state)
        st.hide.animations = state
    end
}, "HideAnimations")

--------------------------------------------------------
-- DISABLE VFX / ROD EFFECT (SAFE HOOK)
--------------------------------------------------------
pcall(function()
    if not mods.VFX then return end
    if mods.VFX._AegisVFXHooked then return end
    mods.VFX._AegisVFXHooked = true

    mods.VFX._AegisOriginalRenderAtPoint = mods.VFX.RenderAtPoint
    mods.VFX._AegisOriginalRenderInstance = mods.VFX.RenderInstance

    mods.VFX.RenderAtPoint = function(self, ...)
        if st.hide.vfx then
            return
        end
        return mods.VFX._AegisOriginalRenderAtPoint(self, ...)
    end

    mods.VFX.RenderInstance = function(self, ...)
        if st.hide.vfx then
            return
        end
        return mods.VFX._AegisOriginalRenderInstance(self, ...)
    end
end)

HideFeature:AddToggle({
    Title = "Disable Rod Effect",
    Content = "Hides the fishing rod bobber effect",
    Default = false,
    Callback = function(state)
        st.hide.vfx = state
    end
}, "HideVFX")


--//======================================================
--// FPS BOOST + SERVER + MERCHANT (CPU SAFE FIX)
--//======================================================
--------------------------------------------------------
-- FPS BOOST (RESTORABLE VERSION)
--------------------------------------------------------

local RunService = game:GetService("RunService")
local Lighting   = game:GetService("Lighting")
local Players    = game:GetService("Players")
local Terrain    = workspace:FindFirstChildOfClass("Terrain")

local LocalPlayer = Players.LocalPlayer

--------------------------------------------------------
-- STATE
--------------------------------------------------------
local FPS_ACTIVE = false
local DescendantConn
local CurrentCharacter

--------------------------------------------------------
-- CACHES (WEAK, RESTORE SAFE)
--------------------------------------------------------
local CachedParts   = setmetatable({}, { __mode = "k" })
local CachedDecals  = setmetatable({}, { __mode = "k" })
local CachedFX      = setmetatable({}, { __mode = "k" })
local CachedLighting = {}
local CachedTerrain  = {}

--------------------------------------------------------
-- CHARACTER TRACK (IMPORTANT)
--------------------------------------------------------
local function UpdateCharacter(char)
    CurrentCharacter = char
end

UpdateCharacter(LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait())
LocalPlayer.CharacterAdded:Connect(UpdateCharacter)

--------------------------------------------------------
-- APPLY
--------------------------------------------------------
local function Apply(obj)
    if not FPS_ACTIVE then return end
    if CurrentCharacter and obj:IsDescendantOf(CurrentCharacter) then return end

    if obj:IsA("BasePart") then
        if not CachedParts[obj] then
            CachedParts[obj] = {
                Transparency = obj.Transparency,
                Material     = obj.Material,
                CastShadow   = obj.CastShadow,
                CanCollide   = obj.CanCollide
            }
        end

        obj.Material = Enum.Material.SmoothPlastic
        obj.CastShadow = false

        if obj.Size.Magnitude > 20 then
            obj.Transparency = 1
            obj.CanCollide = false
        end

    elseif obj:IsA("Decal") or obj:IsA("Texture") then
        if not CachedDecals[obj] then
            CachedDecals[obj] = obj.Transparency
            obj.Transparency = 1
        end

    elseif obj:IsA("ParticleEmitter")
        or obj:IsA("Trail")
        or obj:IsA("Beam")
        or obj:IsA("Fire")
        or obj:IsA("Smoke")
        or obj:IsA("Sparkles") then

        if not CachedFX[obj] then
            CachedFX[obj] = obj.Enabled
            obj.Enabled = false
        end
    end
end

--------------------------------------------------------
-- ENABLE
--------------------------------------------------------
local function EnableFPSBoost()
    if FPS_ACTIVE then return end
    FPS_ACTIVE = true

    -- Lighting
    CachedLighting = {
        GlobalShadows = Lighting.GlobalShadows,
        FogEnd        = Lighting.FogEnd,
        Brightness    = Lighting.Brightness,
        Technology    = Lighting.Technology
    }

    Lighting.GlobalShadows = false
    Lighting.FogEnd = 9e9
    Lighting.Brightness = 1
    Lighting.Technology = Enum.Technology.Compatibility

    -- Terrain
    if Terrain then
        CachedTerrain = {
            WaterWaveSize     = Terrain.WaterWaveSize,
            WaterWaveSpeed    = Terrain.WaterWaveSpeed,
            WaterTransparency = Terrain.WaterTransparency,
            WaterReflectance  = Terrain.WaterReflectance
        }

        Terrain.WaterWaveSize = 0
        Terrain.WaterWaveSpeed = 0
        Terrain.WaterTransparency = 1
        Terrain.WaterReflectance = 0
    end

    -- Initial Scan (BATCH)
    task.spawn(function()
        local i = 0
        for _, obj in ipairs(workspace:GetDescendants()) do
            if not FPS_ACTIVE then break end
            Apply(obj)
            i += 1
            if i % 300 == 0 then task.wait() end
        end
    end)

    -- New Objects
    DescendantConn = workspace.DescendantAdded:Connect(function(obj)
        Apply(obj)
    end)
end

--------------------------------------------------------
-- DISABLE (FULL RESTORE)
--------------------------------------------------------
local function DisableFPSBoost()
    FPS_ACTIVE = false

    if DescendantConn then
        DescendantConn:Disconnect()
        DescendantConn = nil
    end

    -- Restore Parts
    for part, data in pairs(CachedParts) do
        if part and part.Parent then
            part.Transparency = data.Transparency
            part.Material     = data.Material
            part.CastShadow   = data.CastShadow
            part.CanCollide   = data.CanCollide
        end
    end
    CachedParts = setmetatable({}, { __mode = "k" })

    -- Restore Decals
    for d, t in pairs(CachedDecals) do
        if d and d.Parent then
            d.Transparency = t
        end
    end
    CachedDecals = setmetatable({}, { __mode = "k" })

    -- Restore FX
    for fx, st in pairs(CachedFX) do
        if fx and fx.Parent then
            fx.Enabled = st
        end
    end
    CachedFX = setmetatable({}, { __mode = "k" })

    -- Restore Lighting
    for k, v in pairs(CachedLighting) do
        Lighting[k] = v
    end
    CachedLighting = {}

    -- Restore Terrain
    if Terrain then
        for k, v in pairs(CachedTerrain) do
            Terrain[k] = v
        end
    end
    CachedTerrain = {}
end

--==================================================
-- FPS & CPU PROFILING HUD (FIXED & STABLE)
--==================================================

local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

--------------------------------------------------
-- STATE
--------------------------------------------------
local HUD_ENABLED = false
local HUD_GUI = nil
local HUD_THREAD = nil
local FPS_CONN = nil

--------------------------------------------------
-- SAFE STAT READ
--------------------------------------------------
local function SafeStat(fn, default)
    local ok, val = pcall(fn)
    if ok and val ~= nil then
        return val
    end
    return default
end

--------------------------------------------------
-- CREATE HUD
--------------------------------------------------
local function CreateHUD()
    if HUD_GUI then return end

    HUD_GUI = Instance.new("ScreenGui")
    HUD_GUI.Name = "AegisPerformanceHUD"
    HUD_GUI.ResetOnSpawn = false
    HUD_GUI.Parent = CoreGui

    local Frame = Instance.new("Frame")
    Frame.Parent = HUD_GUI
    Frame.Size = UDim2.fromOffset(260, 135)
    Frame.Position = UDim2.new(0, 15, 0.5, -65)
    Frame.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    Frame.BackgroundTransparency = 0.1
    Frame.BorderSizePixel = 0
    Frame.Active = true
    Frame.Draggable = true

    Instance.new("UICorner", Frame).CornerRadius = UDim.new(0, 10)

    local Padding = Instance.new("UIPadding")
    Padding.Parent = Frame
    Padding.PaddingLeft = UDim.new(0, 10)
    Padding.PaddingTop = UDim.new(0, 10)

    local Text = Instance.new("TextLabel")
    Text.Parent = Frame
    Text.Size = UDim2.fromScale(1, 1)
    Text.BackgroundTransparency = 1
    Text.Font = Enum.Font.Code
    Text.TextSize = 14
    Text.TextXAlignment = Enum.TextXAlignment.Left
    Text.TextYAlignment = Enum.TextYAlignment.Top
    Text.TextWrapped = true
    Text.TextColor3 = Color3.fromRGB(0, 255, 170)
    Text.Text = "Initializing..."

    --------------------------------------------------
    -- FPS COUNTER
    --------------------------------------------------
    local frames = 0
    local lastFPS = 0

    FPS_CONN = RunService.RenderStepped:Connect(function()
        frames += 1
    end)

    --------------------------------------------------
    -- UPDATE LOOP
    --------------------------------------------------
    HUD_THREAD = task.spawn(function()
        while HUD_ENABLED and HUD_GUI do
            lastFPS = frames
            frames = 0

            local mem = SafeStat(function()
                return Stats:GetTotalMemoryUsageMb()
            end, 0)

            local phys = SafeStat(function()
                return Stats:GetTotalPhysicsTime() * 1000
            end, 0)

            local drawCalls = SafeStat(function()
                return Stats.RenderStats.DrawCalls:GetValue()
            end, 0)

            local instances = SafeStat(function()
                return Stats.InstanceCount:GetValue()
            end, 0)

            Text.Text = string.format(
                "FPS        : %d\n" ..
                "CPU (Phys) : %.2f ms\n" ..
                "Memory     : %.1f MB\n" ..
                "DrawCalls  : %d\n" ..
                "Instances  : %d",
                lastFPS,
                phys,
                mem,
                drawCalls,
                instances
            )

            task.wait(1)
        end
    end)
end

--------------------------------------------------
-- DESTROY HUD
--------------------------------------------------
local function DestroyHUD()
    HUD_ENABLED = false

    if FPS_CONN then
        FPS_CONN:Disconnect()
        FPS_CONN = nil
    end

    if HUD_THREAD then
        task.cancel(HUD_THREAD)
        HUD_THREAD = nil
    end

    if HUD_GUI then
        HUD_GUI:Destroy()
        HUD_GUI = nil
    end
end

--------------------------------------------------
-- PERFORMANCE TAB
--------------------------------------------------
local MiscSection = Tabs.Misc:AddSection("Performance")

MiscSection:AddToggle({
    Title = "FPS Boost (Stable)",
    Default = false,
    Callback = function(v)
        if v then EnableFPSBoost() else DisableFPSBoost() end
    end
})

MiscSection:AddToggle({
    Title = "Disable 3D Rendering",
    Default = false,
    Callback = function(v)
        if RunService.Set3dRenderingEnabled then
            RunService:Set3dRenderingEnabled(not v)
        end
    end
})

MiscSection:AddToggle({
    Title = "FPS & CPU HUD",
    Content = "Show real FPS & CPU profiling",
    Default = false,
    Callback = function(state)
        HUD_ENABLED = state
        if state then
            CreateHUD()
        else
            DestroyHUD()
        end
    end
})

--------------------------------------------------------
-- AUTO REJOIN (COOLDOWN SAFE)
--------------------------------------------------------
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local AutoServer = {
    Enabled = false,
    AutoKeep = true,
    PlaceId = game.PlaceId,
    JobId = game.JobId,
    LastTry = 0
}

local SAVE_FILE = "AegisHub_Server.json"

local function SaveCurrentServer()
    if writefile then
        writefile(SAVE_FILE, HttpService:JSONEncode({
            PlaceId = game.PlaceId,
            JobId = game.JobId
        }))
    end
end

SaveCurrentServer()

LocalPlayer.OnTeleport:Connect(function(state)
    if state == Enum.TeleportState.Failed then
        local now = os.clock()
        if now - AutoServer.LastTry < 10 then return end
        AutoServer.LastTry = now

        if AutoServer.Enabled then
            pcall(function()
                TeleportService:TeleportToPlaceInstance(
                    AutoServer.PlaceId,
                    AutoServer.JobId,
                    LocalPlayer
                )
            end)
        end
    end
end)

--------------------------------------------------------
-- MERCHANT PANEL (UPDATE ONLY WHEN OPEN)
--------------------------------------------------------
local shop = Tabs.Shop:AddSection("Merchant Shop")

local ShopMerchant = shop:AddParagraph({
    Title = "Merchant Stock Panel",
    Content = "- N/A\n- N/A\n- N/A\n\nNext Refresh: --"
})

local function GetPanelItem(panel)
    local items = {}
    for _, obj in ipairs(panel:GetChildren()) do
        if obj.Name == "Template" then
            local frame = obj:FindFirstChild("Frame")
            if frame and frame:FindFirstChild("ItemName") then
                table.insert(items, frame.ItemName.Text)
            end
        end
    end
    return items
end

local lastMerchantUpdate = 0
RunService.Heartbeat:Connect(function(dt)
    if not gui.Merchant.Enabled then return end

    lastMerchantUpdate += dt
    if lastMerchantUpdate < 3 then return end
    lastMerchantUpdate = 0

    local items = GetPanelItem(gui.ItemsFrame)
    ShopMerchant:SetContent(string.format(
        "- %s\n- %s\n- %s\n\n%s",
        items[1] or "N/A",
        items[2] or "N/A",
        items[3] or "N/A",
        gui.RefreshMerchant.Text
    ))
end)

shop:AddButton({
    Title = "Open / Close Merchant",
    Callback = function()
        gui.Merchant.Enabled = not gui.Merchant.Enabled
    end
})


--==================================================
-- BUY WEATHER (CPU SPIKE FIXED, UI SAME)
--==================================================

local WeatherShop = Tabs.Shop:AddSection("Buy Weather")

--------------------------------------------------
-- DROPDOWN (UNCHANGED)
--------------------------------------------------
WeatherShop:AddDropdown({
  Title = "Select Weather",
  Content = "Select a weather to change to",
  Multi = true,
  Options = {
    "Wind (10,000)",
    "Cloudy (20,000)",
    "Snow (15,000)",
    "Storm (35,000)",
    "Radiant (50,000)",
    "Shark Hunt (300,000)"
  },
  Default = {},
  Callback = function(value)
    st.shop.weather = value
  end
})

--------------------------------------------------
-- AUTO BUY WEATHER (FIXED LOOP)
--------------------------------------------------
local autoWeatherThread = nil

WeatherShop:AddToggle({
  Title = "Auto Buy Weather",
  Content = "Automatically buys selected weather effects",
  Default = false,
  Callback = function(state)
    st.shop.autoWeather = state

    -- ðŸ”’ STOP LOOP SEBELUM BUAT BARU
    if autoWeatherThread then
      task.cancel(autoWeatherThread)
      autoWeatherThread = nil
    end

    if state then
      autoWeatherThread = task.spawn(function()
        while st.shop.autoWeather do
          local list = st.shop.weather
          if list and #list > 0 then
            for _, weather in ipairs(list) do
              pcall(function()
                api.Functions.BuyWeather:InvokeServer(
                  weather:match("^(.-) %(")
                )
              end)
            end
          end
          task.wait(5)
        end
      end)
    end
  end
})


--==================================================
-- TELEPORT ISLANDS (STABLE & SAFE)
--==================================================

local Islands = Tabs.Teleport:AddSection("Teleports Islands")

local TeleportLocations = {
    ["Fishermand Island"] = CFrame.new(251.970, 3.262, 2972.211) * CFrame.Angles(-3.141593, -1.257929, -3.141593),
    ["Crater Island"] = CFrame.new(1072.845, 5.034, 5112.388) * CFrame.Angles(0, 1.229756, 0),
    ["Ancient Jungle"] = CFrame.new(1433.173, 6.625, -782.708) * CFrame.Angles(0, -0.360566, 0),
    ["Kohana"] = CFrame.new(-655.889, 17.250, 483.854) * CFrame.Angles(0, -1.567192, 0),
    ["Volcano"] = CFrame.new(-560.156, 17.091, 110.184) * CFrame.Angles(0, -0.530737, 0),
    ["Sisyphus Statue"] = CFrame.new(-3779.833, -135.074, -971.949) * CFrame.Angles(-3.141593, -1.297434, -3.141593),
    ["Tropical Grove"] = CFrame.new(-2033.356, 6.268, 3679.782) * CFrame.Angles(-3.141593, 0.767602, -3.141593),
    ["Treasure Room"] = CFrame.new(-3649.771, -268.340, -1666.103) * CFrame.Angles(-3.141593, -1.352865, -3.141593),
    ["Sacred Temple"] = CFrame.new(1476.163, -22.125, -675.394) * CFrame.Angles(0, -1.515740, 0),
    ["Coral Reefs"] = CFrame.new(-3132.816, 3.354, 2129.545) * CFrame.Angles(0, -0.597924, 0),
    ["Weather Machine"] = CFrame.new(-1515.702, 2.875, 1912.361) * CFrame.Angles(-3.141593, -0.177870, -3.141593),
    ["Esoteric Dephts"] = CFrame.new(3204.603, -1302.855, 1410.619) * CFrame.Angles(0, 0.454337, 0),
    ["Ancient Ruin"] = CFrame.new(6099.980, -585.924, 4682.759) * CFrame.Angles(3.141535, 1.569459, -3.141535),
    ["Underground Cellar"] = CFrame.new(2135.955, -91.199, -697.068) * CFrame.Angles(0, -0.098867, 0),
    ["Pirate Cove"] = CFrame.new(3399.4023, 4.19197, 3478.9724),
    ["Pirate Treasure Room"] = CFrame.new(3357.8157, -300.9879, 3054.8931),
    ["Crystal Depts"] = CFrame.new(5749.8442, -904.8185, 15387.3975)
}

local function GetNameTeleport()
    local Names = {}
    for name in pairs(TeleportLocations) do
        table.insert(Names, name)
    end
    table.sort(Names)
    return Names
end

Islands:AddDropdown({
    Title = "Select Island",
    Content = "Select an island to teleport to",
    Options = GetNameTeleport(),
    Default = nil,
    Callback = function(value)
        st.teleport.island = value
    end
})

-- DEBOUNCE
local lastTeleport = 0

Islands:AddButton({
    Title = "Teleport",
    Content = "Teleports you to the selected island",
    Callback = function()
        local now = os.clock()
        if now - lastTeleport < 0.5 then return end
        lastTeleport = now

        local loc = TeleportLocations[st.teleport.island]
        if not loc then return end

        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 2)
        if hrp then
            hrp.CFrame = loc
        end
    end
})

--==================================================
-- TELEPORT EVENTS (CLEAN VERSION)
--==================================================

--==================================================
-- TELEPORT EVENTS (FIXED + AUTO RETURN)
--==================================================

local Events = Tabs.Teleport:AddSection("Teleports Events")

--------------------------------------------------
-- CONFIG
--------------------------------------------------
local eventsList = {
    "Shark Hunt",
    "Ghost Shark Hunt",
    "Worm Hunt",
    "Temporary event",
    "Ghost Worm",
    "Black Hole",
    "Megalodon Hunt"
}

local LocalPlayer = game:GetService("Players").LocalPlayer

--------------------------------------------------
-- STATE
--------------------------------------------------
local autoEventTargetName = nil
local autoEventTeleportState = false
local autoEventTeleportThread = nil

local lastLocation = nil
local currentEventModel = nil
local lastEventPosition = nil
local hasReturned = false

--------------------------------------------------
-- SAVE / RETURN POSITION
--------------------------------------------------
local function SaveLastLocation()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
        lastLocation = hrp.CFrame
        return true
    end
    return false
end

local function ReturnToLastLocation()
    if not lastLocation then return end
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = lastLocation
    end
end

--------------------------------------------------
-- FIND EVENT MODEL
--------------------------------------------------
local function FindTargetEvent()
    if not autoEventTargetName then return nil end

    local name = autoEventTargetName
    if name == "Temporary event" then
        name = "Black Hole"
    end

    local props = workspace:FindFirstChild("Props")
    if not props then return nil end

    if name == "Worm Hunt" then
        return props:FindFirstChild("Model")
    end

    return props:FindFirstChild(name)
end

--------------------------------------------------
-- TELEPORT TO EVENT
--------------------------------------------------
local function TeleportToEvent(model)
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not (model and hrp) then return end

    local pos = model:GetPivot().Position
    hrp.CFrame = CFrame.new(pos + Vector3.new(0, 18, 0))

    currentEventModel = model
    lastEventPosition = pos
    hasReturned = false
end

--------------------------------------------------
-- FOLLOW EVENT (AUTO RETURN WHEN ENDED)
--------------------------------------------------
local function FollowEvent()
    -- EVENT HILANG / DESPAWN
    if not currentEventModel or not currentEventModel.Parent then
        if not hasReturned then
            hasReturned = true
            ReturnToLastLocation()
        end

        currentEventModel = nil
        lastEventPosition = nil
        return
    end

    local pos = currentEventModel:GetPivot().Position

    if not lastEventPosition then
        lastEventPosition = pos
        return
    end

    if (pos - lastEventPosition).Magnitude > 6 then
        TeleportToEvent(currentEventModel)
    end
end

--------------------------------------------------
-- MAIN LOOP
--------------------------------------------------
local function StartAutoEventLoop()
    if autoEventTeleportThread then
        task.cancel(autoEventTeleportThread)
        autoEventTeleportThread = nil
    end

    autoEventTeleportThread = task.spawn(function()
        while autoEventTeleportState do
            if not currentEventModel then
                local found = FindTargetEvent()
                if found then
                    TeleportToEvent(found)
                    task.wait(2)
                else
                    task.wait(5)
                end
            else
                FollowEvent()
                task.wait(1)
            end
        end
    end)
end

--------------------------------------------------
-- GUI
--------------------------------------------------
Events:AddDropdown({
    Title = "Select Target Event",
    Content = "Choose event to auto teleport",
    Options = eventsList,
    Callback = function(v)
        autoEventTargetName = v
        currentEventModel = nil
        lastEventPosition = nil
        hasReturned = false
    end
})

Events:AddToggle({
    Title = "Auto Teleport Event",
    Content = "Teleport & follow selected event",
    Default = false,
    Callback = function(state)
        if state and not autoEventTargetName then
            sirenx("Select event first!")
            return
        end

        autoEventTeleportState = state

        if state then
            SaveLastLocation()
            EnableWalkOnWater()
            StartAutoEventLoop()
            sirenx("Auto Event Teleport ON")
        else
            if autoEventTeleportThread then
                task.cancel(autoEventTeleportThread)
                autoEventTeleportThread = nil
            end

            DisableWalkOnWater()
            ReturnToLastLocation()

            currentEventModel = nil
            lastEventPosition = nil
            hasReturned = false

            sirenx("Auto Event Teleport OFF")
        end
    end
})

--------------------------------------------------
-- CHARACTER SAFETY
--------------------------------------------------
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if autoEventTeleportState then
        EnableWalkOnWater()
    end
end)

LocalPlayer.CharacterRemoving:Connect(function()
    autoEventTeleportState = false

    if autoEventTeleportThread then
        task.cancel(autoEventTeleportThread)
        autoEventTeleportThread = nil
    end

    DisableWalkOnWater()
end)


--==================================================
-- TELEPORT PLAYER (CLEAN VERSION)
--==================================================

local Plyr = Tabs.Teleport:AddSection("Teleports Player")

local function GetPlayerNames()
    local names = {}
    for _, plr in ipairs(svc.Players:GetPlayers()) do
        if plr ~= player then
            table.insert(names, plr.Name)
        end
    end
    return names
end

local PlayerList = Plyr:AddDropdown({
    Title = "Select Player",
    Content = "Select a player to teleport to",
    Options = GetPlayerNames(),
    Callback = function(v)
        st.teleport.player = v
    end
})

Plyr:AddButton({
    Title = "Refresh Player List",
    Callback = function()
        PlayerList:SetValues(GetPlayerNames(), st.teleport.player)
    end,
    SubTitle = "Go to Player",
    SubCallback = function()
        local target = svc.Players:FindFirstChild(st.teleport.player)
        if target and target.Character then
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                st.char:PivotTo(target.Character:GetPivot())
            end
        end
    end
})

--==================================================
-- SAVE POSITION FEATURES (SAFE)
--==================================================

local Save = Tabs.Automation:AddSection("Save position Features")

local function SavePosition(cf)
    writefile(PositionFile, svc.HttpService:JSONEncode({ cf:GetComponents() }))
end

local function LoadPosition()
    if not isfile(PositionFile) then return nil end
    local ok, data = pcall(function()
        return svc.HttpService:JSONDecode(readfile(PositionFile))
    end)
    if ok and typeof(data) == "table" then
        return CFrame.new(unpack(data))
    end
end

local restoring = false

local function TeleportLastPos(char)
    if restoring then return end
    restoring = true

    task.delay(2, function()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local last = LoadPosition()
        if hrp and last then
            hrp.CFrame = last
        end
        restoring = false
    end)
end

player.CharacterAdded:Connect(TeleportLastPos)
if player.Character then
    TeleportLastPos(player.Character)
end

Save:AddButton({
    Title = "Save Position",
    Callback = function()
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            SavePosition(hrp.CFrame)
            sirenx("Position saved successfully!")
        end
    end,
    SubTitle = "Reset Position",
    SubCallback = function()
        if isfile(PositionFile) then delfile(PositionFile) end
        sirenx("Last position has been reset.")
    end
})


--//======================================================
--// AUTO ADMIN EVENT (CPU SAFE FIX, GUI SAME)
--//======================================================

local player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")

local AdminEventSection = Tabs.Automation:AddSection("Auto Admin Event")

-- STATUS PARAGRAPH
local countdownParagraph = AdminEventSection:AddParagraph({
    Title = "Ancient Lochness Monster",
    Content = "Waiting for event..."
})

-- STATE
local autoEventEnabled = false
local farmPosition = nil

-- TELEPORT POS
local LOCHNESS_POS = CFrame.new(6063, -586, 4715)

-- GET COUNTDOWN LABEL (SAFE)
local function getCountdownLabel()
    local ok, label = pcall(function()
        return workspace["!!! DEPENDENCIES"]["Event Tracker"]
            .Main.Gui.Content.Items.Countdown.Label
    end)
    return ok and label or nil
end

local countdownLabel = nil
local tickAcc = 0

local function goToEvent()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = LOCHNESS_POS
    end
end

local function returnToFarm()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp and farmPosition then
        hrp.CFrame = farmPosition
    end
end

-- TOGGLE AUTO EVENT
AdminEventSection:AddToggle({
    Title = "Auto Lochness Event",
    Default = false,
    Callback = function(state)
        autoEventEnabled = state

        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if state then
            farmPosition = hrp.CFrame
        else
            returnToFarm()
        end
    end
})

-- HEARTBEAT LOOP (ONLY WORKS WHEN ENABLED)
RunService.Heartbeat:Connect(function(dt)
    if not autoEventEnabled then return end

    tickAcc += dt
    if tickAcc < 1 then return end -- update per 1 second
    tickAcc = 0

    if not countdownLabel or not countdownLabel.Parent then
        countdownLabel = getCountdownLabel()
    end

    local text = countdownLabel and countdownLabel.Text or ""

    if text == "" then
        countdownParagraph:SetContent("Waiting for countdown...")
        return
    end

    countdownParagraph:SetContent("Timer: " .. text)

    local h, m, s = text:match("(%d+)H%s*(%d+)M%s*(%d+)S")
    h, m, s = tonumber(h), tonumber(m), tonumber(s)

    if not h then return end

    -- TELEPORT LOGIC (UNCHANGED)
    if h == 3 and m == 59 and s == 59 then
        goToEvent()
    elseif h == 3 and m == 49 and s == 59 then
        returnToFarm()
    end
end)


--//======================================================
--// AUTO TOTEM (1 HOUR INTERVAL - CPU SAFE, NO AUTO EQUIP)
--//======================================================

local player = game:GetService("Players").LocalPlayer
local RepStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local AutoTotem = Tabs.Automation:AddSection("Auto Totem")

----------------------------------------------------------------
-- REMOTES
----------------------------------------------------------------
local RPath = {"Packages", "_Index", "sleitnick_net@0.2.0", "net"}

local function GetRemote(path, name)
    local cur = RepStorage
    for _, p in ipairs(path) do
        cur = cur:WaitForChild(p, 2)
        if not cur then return nil end
    end
    return cur:FindFirstChild(name)
end

local RE_SpawnTotem = GetRemote(RPath, "RE/SpawnTotem")

----------------------------------------------------------------
-- DATA
----------------------------------------------------------------
local TOTEM_DATA = {
    ["Luck Totem"]     = {Id = 1},
    ["Mutation Totem"] = {Id = 2},
    ["Shiny Totem"]    = {Id = 3},
}

----------------------------------------------------------------
-- STATE
----------------------------------------------------------------
local autoTotemEnabled = false
local selectedTotem = "Luck Totem"
local nextSpawnTime = 0
local SPAWN_INTERVAL = 3600 -- 1 JAM

----------------------------------------------------------------
-- STATUS
----------------------------------------------------------------
local statusParagraph = AutoTotem:AddParagraph({
    Title = "Auto Totem Status",
    Content = "Inactive"
})

----------------------------------------------------------------
-- REPLION INVENTORY (CACHE SAFE)
----------------------------------------------------------------
local ReplionClient
local CachedData

local function GetReplion()
    if not ReplionClient then
        local pkg = RepStorage:WaitForChild("Packages", 5)
        local mod = pkg and pkg:FindFirstChild("Replion")
        if not mod then return nil end

        local ok, m = pcall(require, mod)
        if ok and m.Client then
            ReplionClient = m.Client
        end
    end

    if not CachedData and ReplionClient then
        local ok, d = pcall(function()
            return ReplionClient:WaitReplion("Data", 5)
        end)
        if ok then CachedData = d end
    end

    return CachedData
end

local function GetTotemUUID(name)
    local repl = GetReplion()
    if not repl then return nil end

    local ok, inv = pcall(function()
        return repl:Get("Inventory")
    end)
    if not ok or not inv or not inv.Totems then return nil end

    for _, t in ipairs(inv.Totems) do
        if tonumber(t.Id) == TOTEM_DATA[name].Id and (t.Count or 1) > 0 then
            return t.UUID
        end
    end
end

----------------------------------------------------------------
-- HEARTBEAT LOOP (CPU SAFE)
----------------------------------------------------------------
local tickAcc = 0

RunService.Heartbeat:Connect(function(dt)
    if not autoTotemEnabled then return end

    tickAcc += dt
    if tickAcc < 1 then return end -- update tiap 1 detik
    tickAcc = 0

    local now = os.time()
    local left = nextSpawnTime - now

    if left > 0 then
        local m = math.floor(left / 60)
        local s = left % 60
        statusParagraph:SetContent(
            string.format("Next Spawn: %02d:%02d", m, s)
        )
        return
    end

    local uuid = GetTotemUUID(selectedTotem)
    if not uuid then
        statusParagraph:SetContent("Totem Out of Stock")
        autoTotemEnabled = false
        sirenx("Totem out of stock: " .. selectedTotem)
        return
    end

    pcall(function()
        RE_SpawnTotem:FireServer(uuid)
    end)

    nextSpawnTime = now + SPAWN_INTERVAL
    statusParagraph:SetContent("Totem Spawned")
    sirenx("Totem spawned: " .. selectedTotem)
end)

----------------------------------------------------------------
-- GUI (DROPDOWN TIDAK HILANG)
----------------------------------------------------------------
AutoTotem:AddDropdown({
    Title = "Select Totem",
    Options = {"Luck Totem", "Mutation Totem", "Shiny Totem"},
    Default = "Luck Totem",
    Callback = function(v)
        selectedTotem = v
        nextSpawnTime = 0
        sirenx("Selected Totem: " .. v)
    end
})

AutoTotem:AddToggle({
    Title = "Enable Auto Totem",
    Content = "Spawn totem every 1 hour",
    Default = false,
    Callback = function(state)
        autoTotemEnabled = state
        nextSpawnTime = 0

        if not state then
            statusParagraph:SetContent("Inactive")
        end
    end
})

AutoTotem:AddButton({
    Title = "Spawn Totem Now",
    Content = "Manual spawn",
    Callback = function()
        local uuid = GetTotemUUID(selectedTotem)
        if not uuid then
            sirenx("No totem in inventory")
            return
        end

        pcall(function()
            RE_SpawnTotem:FireServer(uuid)
        end)

        nextSpawnTime = os.time() + SPAWN_INTERVAL
        statusParagraph:SetContent("Totem Spawned")
    end
})

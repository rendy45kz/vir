local Sirenx = loadstring(game:HttpGet("https://raw.githubusercontent.com/rendy45kz/vir/refs/heads/main/aegishub.lua"))()

local Window = Sirenx:Window({
  Title   = "AegisHUB |",
  Footer  = "Fish It",
  Image   = "85286478652862",
  Color   = Color3.fromRGB(244, 244, 245),
  Theme   = 129648704071138,
  Version = 1,
})

local svc = {
  Players     = game:GetService("Players"),
  RunService  = game:GetService("RunService"),
  HttpService = game:GetService("HttpService"),
  RS          = game:GetService("ReplicatedStorage"),
  VU          = game:GetService("VirtualUser"),
  VIM         = game:GetService("VirtualInputManager"),
  PG          = game:GetService("Players").LocalPlayer.PlayerGui,
  Camera      = workspace.CurrentCamera,
  GuiService  = game:GetService("GuiService"),
  CoreGui     = game:GetService("CoreGui"),
  Stats       = game:GetService("Stats"),
  TpService   = game:GetService("TeleportService"),
  Starter     = game:GetService("StarterPlayer"),
  UIS         = game:GetService("UserInputService"),
}

_G.httpRequest =
  (syn and syn.request)
  or (http and http.request)
  or http_request
  or (fluxus and fluxus.request)
  or request
if not _G.httpRequest then
  return
end

local player = svc.Players.LocalPlayer
local function getHRP()
  local char = player.Character or player.CharacterAdded:Wait()
  return char:WaitForChild("HumanoidRootPart")
end
local function getHumanoid()
  local char = player.Character or player.CharacterAdded:Wait()
  return char:WaitForChild("Humanoid")
end

local BaseFolder           = "AegisHub"
local PositionFile         = BaseFolder .. "/Position.json"

local gui = {
  Merchant        = svc.PG.Merchant,
  MerchantRoot    = svc.PG.Merchant.Main.Background,
  ItemsFrame      = svc.PG.Merchant.Main.Background.Items.ScrollingFrame,
  RefreshMerchant = svc.PG.Merchant.Main.Background.RefreshLabel,
}

local mods = {
  Net                     = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
  Replion                 = require(svc.RS.Packages.Replion),
  FishingController       = require(svc.RS.Controllers.FishingController),
  NotificationController  = require(svc.RS.Controllers.NotificationController),
  AnimationController     = require(svc.RS.Controllers.AnimationController),
  CutsceneController      = require(svc.RS.Controllers.CutsceneController),
  TradingController       = require(svc.RS.Controllers.ItemTradingController),
  ItemUtility             = require(svc.RS.Shared.ItemUtility),
  VendorUtility           = require(svc.RS.Shared.VendorUtility),
  CutsceneUtility         = require(svc.RS.Shared.CutsceneUtility),
  PlayerStatsUtility      = require(svc.RS.Shared.PlayerStatsUtility),
  Effects                 = require(svc.RS.Shared.Effects),
  NotifierFish            = require(svc.RS.Controllers.TextNotificationController),
  InputControl            = require(svc.RS.Modules.InputControl),
  VFX                     = require(svc.RS.Controllers.VFXController)
}

local api = {
  Events = {
    RECutscene                    = mods.Net["RE/ReplicateCutscene"],
    REStop                        = mods.Net["RE/StopCutscene"],
    REFav                         = mods.Net["RE/FavoriteItem"],
    REFavChg                      = mods.Net["RE/FavoriteStateChanged"],
    REFishDone                    = mods.Net["RE/FishingCompleted"],
    REFishGot                     = mods.Net["RE/FishCaught"],
    RENotify                      = mods.Net["RE/TextNotification"],
    REEquip                       = mods.Net["RE/EquipToolFromHotbar"],
    REEquipItem                   = mods.Net["RE/EquipItem"],
    REAltar                       = mods.Net["RE/ActivateEnchantingAltar"],
    REAltar2                      = mods.Net["RE/ActivateSecondEnchantingAltar"],
    UpdateOxygen                  = mods.Net["URE/UpdateOxygen"],
    REPlayFishEffect              = mods.Net["RE/PlayFishingEffect"],
    RETextEffect                  = mods.Net["RE/ReplicateTextEffect"],
    REEvReward                    = mods.Net["RE/ClaimEventReward"],
    Totem                         = mods.Net["RE/SpawnTotem"],
    REObtainedNewFishNotification = mods.Net["RE/ObtainedNewFishNotification"],
    FishingMinigameChanged        = mods.Net["RE/FishingMinigameChanged"],
    FishingStopped                = mods.Net["RE/FishingStopped"],
  },

  Functions = {
    Trade       = mods.Net["RF/InitiateTrade"],
    BuyRod      = mods.Net["RF/PurchaseFishingRod"],
    BuyBait     = mods.Net["RF/PurchaseBait"],
    BuyWeather  = mods.Net["RF/PurchaseWeatherEvent"],
    ChargeRod   = mods.Net["RF/ChargeFishingRod"],
    StartMini   = mods.Net["RF/RequestFishingMinigameStarted"],
    UpdateRadar = mods.Net["RF/UpdateFishingRadar"],
    Cancel      = mods.Net["RF/CancelFishingInputs"],
    Dialogue    = mods.Net["RF/SpecialDialogueEvent"],
    SellItem    = mods.Net["RF/SellItem"],
    SellAllItem = mods.Net["RF/SellAllItems"],
    AutoEnabled = mods.Net["RF/UpdateAutoFishingState"]
  }
}

local st                   = {
  player           = player,
  walk             = false,
  walkSpeed        = 16,
  infiniteJump     = false,
  hideIdentity     = false,
  hideNames        = "AegisHUB",
  hideLevels       = "---------",
  char             = player.Character or player.CharacterAdded:Wait(),
  menuRings        = workspace:WaitForChild("!!! MENU RINGS"),
  zones            = workspace:WaitForChild("Zones"),
  vim              = svc.VIM,
  cam              = svc.Camera,
  fishingLegit     = false,
  minigameDelay    = 0.1,
  autoFishing      = false,
  completeDelay    = 0.5,
  instantFishing   = false,

  teleport = {
    island = nil,
    event  = nil,
    player = nil,
  },
  shop = {
    weather       = {},
    autoWeather   = false,
  },
  sell = {
    enabled = false,
    caughtTarget = 100,
    enchantEnabled = false,
    _sellThread = nil,
},
  market = {
    autoSellThreshold = "Legendary",
    sellAtAmount      = 500,
    autoSell          = false,
    enchSellAt        = 100,
    enchSell          = false,
  },
  favorite = {
    auto             = false,
    names            = {},
    rarities         = {},
    mutations        = {},
  },
  hide = {
    notifications   = false,
    cutscenes       = false,
    animations      = false,
    vfx             = false,
  },
  quest = {
    autoDeepSea      = false,
    autoElement      = false,
    autoQuestFlow    = false,
    triggerRuin      = false,
    autoClassicEvent = false,
  },

  perfection = {
    activated = false,   -- toggle manual
    enabled = false,     -- state internal
    autoByInstant = false,
}
}
local ConnectionWalkSpeed = nil
local antiAfkConnection = nil
local oldRequestCharge = nil

local function EnablePerfection()
    if st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(true)
    end)

    pcall(function()
        if not oldRequestCharge then
            oldRequestCharge = mods.FishingController.RequestChargeFishingRod
        end
        mods.FishingController.RequestChargeFishingRod = function()
            return nil
        end
    end)

    st.perfection.enabled = true
end

local function DisablePerfection()
    if not st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(false)
    end)

    pcall(function()
        if oldRequestCharge then
            mods.FishingController.RequestChargeFishingRod = oldRequestCharge
            oldRequestCharge = nil
        end
    end)

    st.perfection.enabled = false
end


st.player.CharacterAdded:Connect(function(char)
  st.char = char
end)

local repl = {
  Data = mods.Replion.Client:WaitReplion("Data"),
  Items = svc.RS:WaitForChild("Items"),
  Variants = svc.RS:WaitForChild("Variants"),
  PlayerStat = require(svc.RS.Packages._Index:FindFirstChild("ytrev_replion@2.0.0-rc.3").replion)
}

player.Idled:Connect(function()
	svc.VU:CaptureController()
	svc.VU:ClickButton2(Vector2.zero)
	st.vim:SendKeyEvent(true, Enum.KeyCode.RightMeta, false, game)
	st.vim:SendKeyEvent(false, Enum.KeyCode.RightMeta, false, game)
end)

local Tabs = {
  Info = Window:AddTab({ Name = "Info", Icon = "player" }),
  Player = Window:AddTab({ Name = "Player", Icon = "user" }),
  Fishing = Window:AddTab({ Name = "Fishing", Icon = "fish" }),
  Shop = Window:AddTab({ Name = "Shop", Icon = "shop" }),
  Automation = Window:AddTab({ Name = "Automation", Icon = "next" }),
  Teleport = Window:AddTab({ Name = "Teleport", Icon = "gps" }),
  Misc = Window:AddTab({ Name = "Misc", Icon = "settings" }),
}

InfoSection = Tabs.Info:AddSection("Information", true)

InfoSection:AddParagraph({
  Title = "Join Whatsapp Server",
  Content = "Join Us!",
  Icon = "whatsapp",
  ButtonText = "Copy Whatsapp Link",
  ButtonCallback = function()
    local link = "https://chat.whatsapp.com/DU81SA1xaoiA5nOvxAr5OR"
    if setclipboard then
      setclipboard(link)
      sirenx("Successfully Copied!")
    end
  end
})

ServerSection = Tabs.Info:AddSection("Server")

local CurrentServer = ServerSection:AddParagraph({
  Title = "Current Server",
  Content = [[
Ping: 0 ms | FPS: 0/s | Players: 0/0
  ]],
  Icon = "stat",
})

task.spawn(function()
  while task.wait(1) do
    CurrentServer:SetContent(
      string.format([[
Ping: %d ms | FPS: %d/s | Players: %d/%d
      ]],
        math.floor(svc.Stats.PerformanceStats.Ping:GetValue() + 0.5),
        math.floor(1 / svc.RunService.RenderStepped:Wait() + 0.5),
        #svc.Players:GetPlayers(),
        svc.Players.MaxPlayers
      )
    )
  end
end)

ServerSection:AddButton({
  Title = "Rejoin Server",
  Content = "Rejoins the current server",
  Callback = function()
    sirenx("Rejoining Server...")
    svc.TpService:Teleport(game.PlaceId, player)
  end
})

Plyrs = Tabs.Player:AddSection("Player")

Plyrs:AddToggle({
  Title = "Enable",
  Content = "Enable Walk Speed Changer",
  Default = false,
  Callback = function(state)
    st.walk = state

    if ConnectionWalkSpeed then
      ConnectionWalkSpeed:Disconnect()
      ConnectionWalkSpeed = nil
    end

    if state then
      local hum = getHumanoid()
      hum.WalkSpeed = st.walkSpeed
      ConnectionWalkSpeed = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if st.walk and hum.WalkSpeed ~= st.walkSpeed then
          hum.WalkSpeed = st.walkSpeed
        end
      end)
    else
      getHumanoid().WalkSpeed = svc.Starter.CharacterWalkSpeed
    end
  end
})

Plyrs:AddSlider({
  Title = "Walk Speed",
  Content = "Change your walk speed",
  Min = 16,
  Max = 500,
  Increment = 1,
  Default = st.walkSpeed,
  Callback = function(value)
    st.walkSpeed = value
    if st.walk then
      getHumanoid().WalkSpeed = value
    end
  end
})

Plyrs:AddToggle({
  Title = "Infinite Jump",
  Content = "Allows you to jump infinitely",
  Default = false,
  Callback = function(state)
    st.infiniteJump = state
    if state then
      svc.UIS.JumpRequest:Connect(function()
        if st.infiniteJump then
          local hum = getHumanoid()
          hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
      end)
    end
  end
}, "InfiniteJump")

local Connections = {}
local OriginalText = {}
local DescendantAddedConnection = nil

local function HandleUsernameChange(Object)
	if not st.hideIdentity or not (Object:IsA("TextLabel") or Object:IsA("TextBox") or Object:IsA("TextButton")) then
		return
	end

	if not Connections[Object] then
		Connections[Object] = Object:GetPropertyChangedSignal("Text"):Connect(function()
			HandleUsernameChange(Object)
		end)
	end

	local text = Object.Text
	if text:find(st.player.Name) or text:find(st.player.DisplayName) then
		OriginalText[Object] = text
		Object.Text = text:gsub(st.player.Name, st.hideNames):gsub(st.player.DisplayName, st.hideNames)
	end
end

Plyrs:AddInput({
  Title = "Set Name",
  Content = "Sets the name to replace your username with",
  Default = st.hideNames,
  Placeholder = st.hideNames,
  Callback = function(value)
    st.hideNames = value
  end
})

Plyrs:AddInput({
  Title = "Set Level Text",
  Content = "Sets the text to replace your level with",
  Default = st.hideLevels,
  Placeholder = st.hideLevels,
  Callback = function(value)
    st.hideLevels = value
  end
})

Plyrs:AddToggle({
	Title = "Hide Identity",
	Content = "Hides your player identity locally",
	Default = false,
	Callback = function(state)
		st.hideIdentity = state

		if state then 
			if DescendantAddedConnection then
				DescendantAddedConnection:Disconnect()
			end

			for i,v in pairs(game:GetDescendants()) do
				pcall(function()
					HandleUsernameChange(v)
				end)
			end

			pcall(function()
				local label = st.char.HumanoidRootPart.Overhead.LevelContainer.Label
				if label and not OriginalText[label] then
					OriginalText[label] = label.Text
				end
				label.Text = st.hideLevels
			end)

			DescendantAddedConnection = game.DescendantAdded:Connect(function(v)
				pcall(function()
					HandleUsernameChange(v)
				end)
			end)
		else
			if DescendantAddedConnection then
				DescendantAddedConnection:Disconnect()
				DescendantAddedConnection = nil
			end

			for Object, Connection in pairs(Connections) do
				if Connection then
					Connection:Disconnect()
				end
			end
			Connections = {}

			if OriginalText then
				for Object, Text in pairs(OriginalText) do
					if Object and Object.Parent then
						pcall(function()
							Object.Text = Text
						end)
					end
				end
				OriginalText = {}
			end
		end
	end
})

local Camera = Tabs.Player:AddSection("Camera")

Camera:AddToggle({
  Title = "Max Zoom",
  Content = "Allows you to zoom out the furthest",
  Default = false,
  Callback = function(state)
    ConnectionZoom = ConnectionZoom or nil

    if ConnectionZoom then
      ConnectionZoom:Disconnect()
      ConnectionZoom = nil
    end

    if state then
      st.player.CameraMaxZoomDistance = 50000
      ConnectionZoom = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
        if st.player.CameraMaxZoomDistance ~= 50000 then
          st.player.CameraMaxZoomDistance = 50000
        end
      end)
    else
      st.player.CameraMaxZoomDistance = svc.Starter.CameraMaxZoomDistance
    end
  end
})

local AutoFishing = Tabs.Fishing:AddSection("Instant Fishing")

api.Events.RETextEffect.OnClientEvent:Connect(function(data)
  if not (data and data.TextData and data.TextData.EffectType == "Exclaim") then return end
  if not (st.char and data.Container == st.char:FindFirstChild("Head")) then return end

  if st.autoFishing then
    task.delay(st.completeDelay, function()
      pcall(api.Events.REFishDone.FireServer, api.Events.REFishDone)
    end)
  end
end)

AutoFishing:AddToggle({
  Title = "Instant Fishing",
  Content = "Automatically fishes for you",
  Default = false,
  Callback = function(state)
    st.autoFishing = state

    task.spawn(function()
      api.Functions.AutoEnabled:InvokeServer(state)
      while st.autoFishing do
        api.Functions.ChargeRod:InvokeServer()
        api.Functions.StartMini:InvokeServer(-1, 0.999, workspace:GetServerTimeNow())
        task.wait(0.5)
      end
    end)
  end
})

AutoFishing:AddInput({
  Title = "Complete Delay",
  Content = "Delay for complete fishing",
  Default = tostring(st.completeDelay),
  Callback = function(value)
    local num = tonumber(value)
    if not num or num < 0 or num > 5 then
      task.spawn(function()
        task.wait()
        CD:Set(tostring(st.completeDelay))
        sirenx("Invalid number! Must be between 0 and 5.")
      end)
    end
    st.completeDelay = num
  end
})

local Fish2 = Tabs.Fishing:AddSection("Blatant Fishing")

-- CACHE API (LEBIH CEPAT)
local Func = api.Functions
local Ev   = api.Events
local GetNow = workspace.GetServerTimeNow

-- =====================================================
-- FASTEST (OPTIMIZED)
-- =====================================================
local function Fastest()
    -- 1 THREAD SAJA (NO SPAWN STACKING)
    local now = GetNow(workspace)

    pcall(Func.Cancel.InvokeServer, Func.Cancel)
    pcall(Func.ChargeRod.InvokeServer, Func.ChargeRod, now)
    pcall(Func.StartMini.InvokeServer, Func.StartMini, -1, 0.999)

    task.wait(_G.FishingDelay)

    pcall(Ev.REFishDone.FireServer, Ev.REFishDone)
end

-- =====================================================
-- BLATANT TOGGLE
-- =====================================================
Fish2:AddToggle({
    Title = "Blatant Fishing",
    Default = _G.FBlatant,
    Callback = function(s)
        _G.FBlatant = s
        Func.AutoEnabled:InvokeServer(s)

        if s then
            -- AUTO PERFECTION
            st.perfection.autoByInstant = true
            EnablePerfection()

            st.player:SetAttribute("Loading", nil)

            -- MAIN LOOP (STABLE)
            task.spawn(function()
                while _G.FBlatant do
                    Fastest()
                    task.wait(_G.Reel)
                end
            end)
        else
            st.player:SetAttribute("Loading", false)

            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})

-- =====================================================
-- INPUTS
-- =====================================================
Fish2:AddInput({
    Title = "Delay Reel",
    Value = tostring(_G.Reel),
    Default = "1.9",
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            _G.Reel = n
            SaveConfig()
        end
    end
})

Fish2:AddInput({
    Title = "Delay Fishing",
    Value = tostring(_G.FishingDelay),
    Default = "1.1",
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            _G.FishingDelay = n
            SaveConfig()
        end
    end
})

--//======================================================
--// ULTRA BLATANT FISHING (OPTIMIZED)
--//======================================================

local UltraBlatant = {
    Active = false,
    CompleteDelay = 0.7,
    CancelDelay = 0.3,
    Thread = nil
}

-- SAFE CALL (NO SPAWN STACK)
local function SafeCall(fn, ...)
    local ok = pcall(fn, ...)
    return ok
end

-- ULTRA CAST (FASTER)
local function UltraCast()
    local now = GetNow(workspace)

    SafeCall(Func.ChargeRod.InvokeServer, Func.ChargeRod, now)
    task.wait() -- yield 1 frame
    SafeCall(Func.StartMini.InvokeServer, Func.StartMini, -1, 0.999)
end

-- ULTRA LOOP (HIGH SPEED)
local function UltraLoop()
    while UltraBlatant.Active do
        UltraCast()

        task.wait(UltraBlatant.CompleteDelay)

        if not UltraBlatant.Active then break end
        SafeCall(Ev.REFishDone.FireServer, Ev.REFishDone)

        task.wait(UltraBlatant.CancelDelay)

        if not UltraBlatant.Active then break end
        SafeCall(Func.Cancel.InvokeServer, Func.Cancel)
    end
end

-- =====================================================
-- GUI SECTION
-- =====================================================
local UltraSection = Tabs.Fishing:AddSection("Blatant BETA")

UltraSection:AddToggle({
    Title = "Ultra Blatant Fishing",
    Content = "Extremely fast & aggressive fishing",
    Default = false,
    Callback = function(state)
        UltraBlatant.Active = state

        if state then
            st.perfection.autoByInstant = true
            EnablePerfection()

            SafeCall(Ev.REEquip.FireServer, Ev.REEquip, 1)

            task.wait(0.15)

            UltraBlatant.Thread = task.spawn(UltraLoop)
        else
            UltraBlatant.Active = false

            SafeCall(Func.Cancel.InvokeServer, Func.Cancel)

            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})

UltraSection:AddInput({
    Title = "Complete Delay",
    Content = "Delay before fish completed",
    Default = tostring(UltraBlatant.CompleteDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then
            UltraBlatant.CompleteDelay = n
        end
    end
})

UltraSection:AddInput({
    Title = "Cancel Delay",
    Content = "Delay before cancel input",
    Default = tostring(UltraBlatant.CancelDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then
            UltraBlatant.CancelDelay = n
        end
    end
})

local FishFeature = Tabs.Fishing:AddSection("Fishing Features")

FishFeature:AddToggle({
    Title = "Perfection Support",
    Content = "Enable perfection & block rod charging",
    Default = false,
    Callback = function(state)
        st.perfection.activated = state

        if state then
            EnablePerfection()
        else
            -- jangan matikan jika Instant Fishing aktif
            if not st.perfection.autoByInstant then
                DisablePerfection()
            end
        end
    end
})

FishFeature:AddButton({
  Title = "Recovery Fishing",
  Callback = function()
    task.spawn(function()
      pcall(function()
        api.Functions.Cancel:InvokeServer()
      end)
      local lp = game:GetService("Players").LocalPlayer
      lp:SetAttribute("Loading", nil)
      task.wait(0.05)
      lp:SetAttribute("Loading", false)
      sirenx("Recovery Successfully!")
    end)
  end
})

local SellGroup = Tabs.Fishing:AddSection("Auto Selling")

----------------------------------------------------------------
-- AUTO FAVORITE + AUTO SELL HANDLER (EVENT-DRIVEN)
----------------------------------------------------------------
local autoSellCount    = 0
local autoSellCooldown = false

RE_ObtainedNewFish.OnClientEvent:Connect(function(itemId, _, info)
    if not info or not info.InventoryItem then return end
    local uuid = info.InventoryItem.UUID
    if not uuid then return end

    ------------------------------------------------------------
    -- COUNTER FISH (SELALU JALAN)
    ------------------------------------------------------------
    autoSellCount += 1

    ------------------------------------------------------------
    -- AUTO SELL (BERDASARKAN JUMLAH IKAN DIDAPAT)
    ------------------------------------------------------------
    if not st.sell.enabled then return end
    if autoSellCooldown then return end

    local target = tonumber(st.sell.caughtTarget) or 0
    if target <= 0 then return end

    if autoSellCount >= target then
        autoSellCooldown = true

        task.spawn(function()
            pcall(function()
                api.Functions.SellAllItem:InvokeServer()
            end)

            sirenx(("Auto Sell: %d fish sold"):format(autoSellCount))

            -- RESET COUNTER
            autoSellCount = 0

            -- COOLDOWN (ANTI SPAM)
            task.wait(1.5)
            autoSellCooldown = false
        end)
    end
end)

SellGroup:AddInput({
    Title = "Sell When Caught â‰¥",
    Content = "Auto sell after catching X fish",
    Default = tostring(st.sell.caughtTarget),
    Numeric = true,
    Callback = function(v)
        st.sell.caughtTarget = tonumber(v) or 0
        sirenx("Auto Sell target set to " .. st.sell.caughtTarget)
    end
})

SellGroup:AddToggle({
    Title = "Auto Sell by Fish Caught",
    Content = "Sell all fish after reaching target count",
    Default = false,
    Callback = function(state)
        st.sell.enabled = state

        if state then
            autoSellCount = 0 -- reset saat ON
            sirenx("Auto Sell by Fish Caught enabled")
        else
            sirenx("Auto Sell disabled")
        end
    end
})

local Favorites = Tabs.Fishing:AddSection("Favorites")

local function IsFavorited(UUID, items)
  for _, Item in pairs(items) do
    if Item.UUID == UUID then return Item.Favorited == true end
  end
  return false
end

local RarityOrder = {Common = 1, Uncommon = 2, Rare = 3, Epic = 4, Legendary = 5, Mythic = 6, Secret = 7}

local function AutoFavorite(names, rarities, mutations)
  local items = repl.Data.Data.Inventory.Items
  if not items or #items == 0 then return end

  local rarityTiers, namesList, mutationList = {}, {}, {}
  
  if rarities then
    for _, rarity in ipairs(rarities) do
      if RarityOrder[rarity] then 
        rarityTiers[RarityOrder[rarity]] = true
      end
    end
  end

  if names then for _, name in ipairs(names) do namesList[name] = true end end
  if mutations then for _, mutation in ipairs(mutations) do mutationList[mutation] = true end end

  local toFavorite = {}
  
  for _, Item in pairs(items) do
    if not Item.Favorited then
      local FishData = mods.ItemUtility:GetItemData(Item.Id)
      
      if FishData and FishData.Data then
        local data = FishData.Data
        if namesList[data.Name] or rarityTiers[data.Tier] or (Item.Metadata and Item.Metadata.VariantId and mutationList[Item.Metadata.VariantId]) then
          table.insert(toFavorite, Item.UUID)
        end
      end
    end
  end

  for i, uuid in ipairs(toFavorite) do
    task.spawn(function()
      task.wait(i * 0.05)
      api.Events.REFav:FireServer(uuid)
    end)
  end
end

local function UnAutoFavoriteAll()
  local Items = repl.Data.Data.Inventory.Items
  if not Items or #Items == 0 then return end

  for _, Item in pairs(Items) do
    if IsFavorited(Item.UUID) then
      pcall(api.Events.REFav.FireServer, api.Events.REFav, Item.UUID)
    end
  end
end

Favorites:AddDropdown({
  Title = "Auto Favorite by Rarity",
  Content = "Favorite by Fish Rarity",
  Multi = true,
  Options = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "Secret"},
  Default = st.favorite.rarities,
  Callback = function(value)
    st.favorite.rarities = value
  end
})

local cachedFishNames = nil
local function GetFishNames()
  if cachedFishNames then return cachedFishNames end
  
  local Names = {}
  for _, Item in pairs(repl.Items:GetChildren()) do
    local FishData = mods.ItemUtility:GetItemData(Item.Name)
    if FishData and FishData.Data and FishData.Data.Type == "Fish" then
      table.insert(Names, FishData.Data.Name)
    end
  end
  cachedFishNames = Names
  return Names
end

Favorites:AddDropdown({
  Title = "Auto Favorite by Name",
  Content = "Favorite by Fish Name",
  Multi = true,
  Options = GetFishNames(),
  Default = st.favorite.names,
  Callback = function(value)
    st.favorite.names = value
  end
})

local cachedMutations = nil
local function GetFishMutation()
  if cachedMutations then return cachedMutations end
  
  local Names = {}
  for _, Item in pairs(repl.Variants:GetChildren()) do
    table.insert(Names, Item.Name)
  end
  cachedMutations = Names
  return Names
end

Favorites:AddDropdown({
  Title = "Auto Favorite by Mutation",
  Content = "Favorite by Fish Mutation",
  Multi = true,
  Options = GetFishMutation(),
  Default = st.favorite.mutations,
  Callback = function(value)
    st.favorite.mutations = value
  end
})

Favorites:AddToggle({
  Title = "Auto Favorite",
  Content = "Automatically favorites fish for you",
  Default = false,
  Callback = function(state)
    st.favorite.auto = state

    task.spawn(function()
      while st.favorite.auto do
        AutoFavorite(st.favorite.names, st.favorite.rarities, st.favorite.mutations)
        task.wait(2)
      end
    end)
  end
})

Favorites:AddButton({
  Title = "Unfavorite All",
  Content = "Unfavorites all favorited fish",
  Callback = UnAutoFavoriteAll
})

local HideFeature = Tabs.Misc:AddSection("Hide Features")

HideFeature:AddToggle({
    Title = "Anti AFK",
    Content = "Prevents you from being kicked for idling",
    Default = true, -- ðŸ”¥ AUTO ON
    Callback = function(state)
        local VirtualUser = game:GetService("VirtualUser")

        if state then
            -- Hindari double connection
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end

            antiAfkConnection = player.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        else
            -- Matikan Anti AFK dengan benar
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
        end
    end
})

pcall(function()
  local OriginalNotif = mods.NotificationController.PlaySmallItemObtained
  mods.NotificationController.PlaySmallItemObtained = function(self, ...)
    if st.hide.notifications then return end
    return OriginalNotif(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Hide Notification",
  Content = "Hides get fishing notifications",
  Default = false,
  Callback = function(state)
    st.hide.notifications = state
  end
}, "HideNotification")

pcall(function()
  local OriginalInit = mods.CutsceneController.Init
  mods.CutsceneController.Init = function(self, ...)
    if st.hide.cutscenes then return end
    return OriginalInit(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Skip Cutscenes",
  Content = "Automatically skips fishing cutscenes",
  Default = false,
  Callback = function(state)
    st.hide.cutscenes = state
  end
}, "HideCutscenes")

pcall(function()
  local OriginalAnim = mods.AnimationController.PlayAnimation
  mods.AnimationController.PlayAnimation = function(self, ...)
    if st.hide.animations then return end
    return OriginalAnim(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Disable Animations",
  Content = "Disables fishing animations",
  Default = false,
  Callback = function(state)
    st.hide.animations = state
  end
}, "HideAnimations")

pcall(function()
  local OriginalRenderAP = mods.VFX.RenderAtPoint
  mods.VFX.RenderAtPoint = function(self, ...)
    if st.hide.vfx then return end
    return OriginalRenderAP(self, ...)
  end

  local OriginalRenderI = mods.VFX.RenderInstance
  mods.VFX.RenderInstance = function(self, ...)
    if st.hide.vfx then return end
    return OriginalRenderI(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Disable Rod Effect",
  Content = "Hides the fishing rod bobber effect",
  Default = false,
  Callback = function(state)
    st.hide.vfx = state
  end
}, "HideVFX")

--======================================================
-- FPS BOOST SYSTEM (STABLE & CLEAN)
--======================================================

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local fpsRunning = false
local fpsConnections = {}

-- PROTECTED OBJECTS
local function IsProtected(obj)
    if obj:IsDescendantOf(player:WaitForChild("PlayerGui")) then return true end
    if obj:IsDescendantOf(game:GetService("StarterGui")) then return true end
    if obj:IsDescendantOf(game:GetService("ReplicatedStorage")) then return true end
    return false
end

-- NUKER
local function Nuke(obj)
    if not fpsRunning or IsProtected(obj) then return end

    if obj:IsA("ParticleEmitter")
    or obj:IsA("Trail")
    or obj:IsA("Beam")
    or obj:IsA("Fire")
    or obj:IsA("Smoke")
    or obj:IsA("Sparkles")
    or obj:IsA("Highlight") then
        obj:Destroy()
        return
    end

    if obj:IsA("Decal")
    or obj:IsA("Texture")
    or obj:IsA("SurfaceAppearance") then
        obj:Destroy()
        return
    end

    if obj:IsA("PointLight")
    or obj:IsA("SpotLight")
    or obj:IsA("SurfaceLight") then
        obj:Destroy()
        return
    end

    if obj:IsA("MeshPart") then
        obj.TextureID = ""
        obj.Material = Enum.Material.SmoothPlastic
        obj.Reflectance = 0
        obj.CastShadow = false
    end

    if obj:IsA("BasePart") then
        obj.Material = Enum.Material.SmoothPlastic
        obj.Color = Color3.fromRGB(170,170,170)
        obj.Reflectance = 0
        obj.CastShadow = false
    end
end

-- APPLY BOOST
local function EnableFPSBoost()
    if fpsRunning then return end
    fpsRunning = true

    -- Lighting optimize
    Lighting.GlobalShadows = false
    Lighting.FogEnd = 1e6
    Lighting.Brightness = 1
    Lighting.ClockTime = 14

    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            v:Destroy()
        end
    end

    -- Water optimize
    local terrain = Workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        terrain.WaterWaveSize = 0
        terrain.WaterWaveSpeed = 0
        terrain.WaterReflectance = 0
        terrain.WaterTransparency = 1
    end

    -- Initial nuke
    for _, v in ipairs(game:GetDescendants()) do
        Nuke(v)
    end

    -- Connections
    table.insert(fpsConnections, game.DescendantAdded:Connect(function(obj)
        task.wait()
        Nuke(obj)
    end))

    local function OnChar(char)
        for _, v in ipairs(char:GetDescendants()) do
            Nuke(v)
        end
        table.insert(fpsConnections, char.DescendantAdded:Connect(Nuke))
    end

    if player.Character then
        OnChar(player.Character)
    end

    table.insert(fpsConnections, player.CharacterAdded:Connect(OnChar))

    table.insert(fpsConnections, RunService.RenderStepped:Connect(function()
        if fpsRunning then
            settings().Rendering.QualityLevel = 1
        end
    end))
end

-- DISABLE BOOST
local function DisableFPSBoost()
    fpsRunning = false
    for _, c in ipairs(fpsConnections) do
        pcall(function() c:Disconnect() end)
    end
    fpsConnections = {}
end

--======================================================
-- GUI : FPS BOOST
--======================================================

local MiscSection = Tabs.Misc:AddSection("Performance")

MiscSection:AddToggle({
    Title = "Boost FPS",
    Content = "Reduces graphics and effects to increase performance",
    Default = false,
    Callback = function(state)
        if state then
            EnableFPSBoost()
        else
            DisableFPSBoost()
        end
    end
})

MiscSection:AddToggle({
    Title = "Disable 3D Rendering",
    Content = "Disables 3D rendering to reduce GPU usage",
    Default = false,
    Callback = function(state)
        setfpscap(60)
        if RunService.Set3dRenderingEnabled then
            RunService:Set3dRenderingEnabled(not state)
        end
    end
})


local shop = Tabs.Shop:AddSection("Merchant Shop")

local ShopMerchant = shop:AddParagraph({
  Title = "Merchant Stock Panel",
  Content = [[
- N/A
- N/A
- N/A

Next Refresh: 00H, 00M, 00S
  ]]
})

local function GetPanelItem(Panel)
  local Items = {}
  for _, Obj in ipairs(Panel:GetChildren()) do
    if Obj.Name == "Template" then
      local ItemName = Obj:FindFirstChild("Frame")
      if ItemName and ItemName:FindFirstChild("ItemName") then
        table.insert(Items, ItemName.ItemName.Text)
      end
    end
  end
  return Items
end

task.spawn(function()
  while task.wait(3) do
    local items = GetPanelItem(gui.ItemsFrame)
    ShopMerchant:SetContent(
      string.format([[
- %s
- %s
- %s

%s
      ]],
        items[1] or "N/A",
        items[2] or "N/A",
        items[3] or "N/A",
        gui.RefreshMerchant.Text
      ))
  end
end)

shop:AddButton({
  Title = "Open / Close Merchant",
  Content = "Opens or closes the merchant shop panel",
  Callback = function()
    gui.Merchant.Enabled = not gui.Merchant.Enabled
  end
})

local WeatherShop = Tabs.Shop:AddSection("Buy Weather")


WeatherShop:AddDropdown({
  Title = "Select Weather",
  Content = "Select a weather to change to",
  Multi = true,
  Options = {
    "Wind (10,000)",
    "Cloudy (20,000)",
    "Snow (15,000)",
    "Storm (35,000)",
    "Radiant (50,000)",
    "Shark Hunt (300,000)"
  },
  Default = {},
  Callback = function(value)
    st.shop.weather = value
  end
})

WeatherShop:AddToggle({
  Title = "Auto Buy Weather",
  Content = "Automatically buys selected weather effects",
  Default = false,
  Callback = function(state)
    st.shop.autoWeather = state

    task.spawn(function()
      while st.shop.autoWeather and st.shop.weather do
        for _, weather in ipairs(st.shop.weather) do
          api.Functions.BuyWeather:InvokeServer(weather:match("^(.-) %("))
        end
        task.wait(5)
      end
    end)
  end
})

local Islands= Tabs.Teleport:AddSection("Teleports Islands")

local TeleportLocations = {
  ["Fishermand Island"] = CFrame.new(251.970, 3.262, 2972.211) * CFrame.Angles(-3.141593, -1.257929, -3.141593),
	["Crater Island"] = CFrame.new(1072.845, 5.034, 5112.388) * CFrame.Angles(-0.000000, 1.229756, -0.000000),
	["Ancient Jungle"] = CFrame.new(1433.173, 6.625, -782.708) * CFrame.Angles(-0.000000, -0.360566, -0.000000),
	["Kohana"] = CFrame.new(-655.889, 17.250, 483.854) * CFrame.Angles(-0.000000, -1.567192, -0.000000),
	["Volcano"] = CFrame.new(-560.156, 17.091, 110.184) * CFrame.Angles(-0.000000, -0.530737, -0.000000),
	["Sisyphus Statue"] = CFrame.new(-3779.833, -135.074, -971.949) * CFrame.Angles(-3.141593, -1.297434, -3.141593),
	["Tropical Grove"] = CFrame.new(-2033.356, 6.268, 3679.782) * CFrame.Angles(-3.141593, 0.767602, -3.141593),
	["Treasure Room"] = CFrame.new(-3649.771, -268.340, -1666.103) * CFrame.Angles(-3.141593, -1.352865, -3.141593),
	["Sacred Temple"] = CFrame.new(1476.163, -22.125, -675.394) * CFrame.Angles(-0.000000, -1.515740, -0.000000),
	["Coral Reefs"] = CFrame.new(-3132.816, 3.354, 2129.545) * CFrame.Angles(-0.000000, -0.597924, -0.000000),
	["Weather Machine"] = CFrame.new(-1515.702, 2.875, 1912.361) * CFrame.Angles(-3.141593, -0.177870, -3.141593),
	["Esoteric Dephts"] = CFrame.new(3204.603, -1302.855, 1410.619) * CFrame.Angles(-0.000000, 0.454337, -0.000000),
	["Ancient Ruin"] = CFrame.new(6099.980, -585.924, 4682.759) * CFrame.Angles(3.141535, 1.569459, -3.141535),
	["Classic Island"] = CFrame.new(1226.521, 4.000, 2774.871) * CFrame.Angles(0.000000, 0.006386, -0.000000),
	["Iron Cavern"] = CFrame.new(-8800.321, -585.000, 83.745) * CFrame.Angles(-0.000000, -0.943772, 0.000000),
	["Iron Cafe"] = CFrame.new(-8642.318, -547.500, 158.730) * CFrame.Angles(0.000000, -1.559896, 0.000000),
	["Underground Cellar"] = CFrame.new(2135.955, -91.199, -697.068) * CFrame.Angles(-0.000000, -0.098867, 0.000000),
	["Christmas Island 1"] = CFrame.new(666.372, 5.080, 1617.845) * CFrame.Angles(0.000000, 0.793008, 0.000000),
	["Christmas Island 2"] = CFrame.new(1161.302, 23.762, 1530.955) * CFrame.Angles(0.000000, 2.861345, 0.000000)
}

local function GetNameTeleport()
  local Names = {}
  for Key,_ in pairs(TeleportLocations) do table.insert(Names, Key) end
  return Names
end

Islands:AddDropdown({
  Title = "Select Island",
  Content = "Select an island to teleport to",
  Options = GetNameTeleport(),
  Default = nil,
  Callback = function(value)
    st.teleport.island = value
  end
})

Islands:AddButton({
  Title = "Teleport",
  Content = "Teleports you to the selected island",
  Callback = function()
    local loc = TeleportLocations[st.teleport.island]
    if not loc then return end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
      hrp.CFrame = loc
      sirenx("Teleported to " .. st.teleport.island)
    end
  end
})

local Events = Tabs.Teleport:AddSection("Teleports Events")

-- ===============================
-- EVENT AUTO TELEPORT (GUI MATCH)
-- ===============================

local eventsList = { 
    "Shark Hunt",
    "Ghost Shark Hunt",
    "Worm Hunt",
    "Temporary event",
    "Ghost Worm",
    "Black Hole",
    "Megalodon Hunt"

}

local autoEventTargetName = nil 
local autoEventTeleportState = false
local autoEventTeleportThread = nil
local lastLocation = nil
local currentEventModel = nil
local lastEventPosition = nil
 
-- VARIABEL WALK ON WATER
local walkOnWaterConnection = nil
local isWalkOnWater = false
local waterPlatform = nil
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = game.Players.LocalPlayer
 
-- FUNGSI SAVE LAST LOCATION (simpan ketika enable)
local function SaveLastLocation()
    local character = LocalPlayer.Character
    if not character then return false end
 
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
 
    lastLocation = hrp.CFrame
    return true
end

-- FUNGSI RETURN TO LAST LOCATION
local function ReturnToLastLocation()
    if not lastLocation then return false end
 
    local character = LocalPlayer.Character
    if not character then return false end
 
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
 
    hrp.CFrame = lastLocation
    return true
end

-- FUNGSI WALK ON WATER
local function EnableWalkOnWater()
    if isWalkOnWater then return end
 
    isWalkOnWater = true
 
    if not waterPlatform then
        waterPlatform = Instance.new("Part")
        waterPlatform.Name = "WaterPlatform"
        waterPlatform.Anchored = true
        waterPlatform.CanCollide = true
        waterPlatform.Transparency = 1 
        waterPlatform.Size = Vector3.new(15, 1, 15)
        waterPlatform.Parent = workspace
    end
 
    if walkOnWaterConnection then 
        walkOnWaterConnection:Disconnect() 
    end
 
    walkOnWaterConnection = game:GetService("RunService").RenderStepped:Connect(function()
        if not isWalkOnWater then return end
 
        local character = LocalPlayer.Character
        if not character then return end
 
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
 
        if not waterPlatform or not waterPlatform.Parent then
            waterPlatform = Instance.new("Part")
            waterPlatform.Name = "WaterPlatform"
            waterPlatform.Anchored = true
            waterPlatform.CanCollide = true
            waterPlatform.Transparency = 1 
            waterPlatform.Size = Vector3.new(15, 1, 15)
            waterPlatform.Parent = workspace
        end
 
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {workspace.Terrain} 
        rayParams.FilterType = Enum.RaycastFilterType.Include
        rayParams.IgnoreWater = false
 
        local rayOrigin = hrp.Position + Vector3.new(0, 5, 0) 
        local rayDirection = Vector3.new(0, -500, 0)
        local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
 
        if result and result.Material == Enum.Material.Water then
            local waterSurfaceHeight = result.Position.Y
            waterPlatform.Position = Vector3.new(hrp.Position.X, waterSurfaceHeight, hrp.Position.Z)
 
            if hrp.Position.Y < (waterSurfaceHeight + 2) and hrp.Position.Y > (waterSurfaceHeight - 5) then
                if not UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    hrp.CFrame = CFrame.new(hrp.Position.X, waterSurfaceHeight + 3.2, hrp.Position.Z)
                end
            end
        else
            waterPlatform.Position = Vector3.new(hrp.Position.X, -500, hrp.Position.Z)
        end
    end)
end

local function DisableWalkOnWater()
    if not isWalkOnWater then return end
 
    isWalkOnWater = false
 
    if walkOnWaterConnection then 
        walkOnWaterConnection:Disconnect() 
        walkOnWaterConnection = nil 
    end
 
    if waterPlatform then 
        waterPlatform:Destroy() 
        waterPlatform = nil 
    end
end

-- FUNGSI CARI EVENT
local function FindTargetEvent()
    if not autoEventTargetName then return nil end
 
    local searchName = autoEventTargetName
    if searchName == "Temporary event" then
        searchName = "Black Hole"
    end
 
    for _, child in pairs(workspace:GetChildren()) do
        if child.Name == "Props" then
            local eventModel = nil
 
            if searchName == "Worm Hunt" then
                eventModel = child:FindFirstChild("Model")
            else
                eventModel = child:FindFirstChild(searchName)
            end
 
            if eventModel then
                return eventModel
            end
        end
    end
 
    return nil
end

-- TELEPORT

local function TeleportToEvent(eventModel)
    if not eventModel then return false end
 
    local character = LocalPlayer.Character
    if not character then return false end
 
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
 
    local targetPos = eventModel:GetPivot().Position
    hrp.CFrame = CFrame.new(targetPos + Vector3.new(0, 15, 0))
 
    currentEventModel = eventModel
    lastEventPosition = targetPos
 
    return true
end

local function HasEventMoved()
    if not currentEventModel or not currentEventModel.Parent then
        return true
    end
 
    local currentPos = currentEventModel:GetPivot().Position
    if not lastEventPosition then return true end
 
    local distance = (currentPos - lastEventPosition).Magnitude
    return distance > 5
end

local function FollowMovingEvent()
    if not currentEventModel then return false end
 
    if not currentEventModel.Parent then
        currentEventModel = nil
        lastEventPosition = nil
        return false
    end
 
    if HasEventMoved() then
        return TeleportToEvent(currentEventModel)
    end
 
    return false
end

local function FindAndTeleportToTargetEvent()
    if not autoEventTargetName then return false end
 
    local eventModel = FindTargetEvent()
    if eventModel then
        return TeleportToEvent(eventModel)
    end
 
    return false
end
 
-- FUNGSI UNTUK RESTART AUTO TELEPORT LOOP
local function RestartAutoTeleportLoop()
    if not autoEventTeleportState then return end
 
    if autoEventTeleportThread then 
        task.cancel(autoEventTeleportThread) 
        autoEventTeleportThread = nil
    end
 
    currentEventModel = nil
    lastEventPosition = nil
 
    autoEventTeleportThread = task.spawn(function()
        while autoEventTeleportState do
            local success = FindAndTeleportToTargetEvent()
 
            if success then
                for i = 1, 180 do
                    if not autoEventTeleportState then break end
                    FollowMovingEvent()
                    task.wait(5)
                end
            else
                task.wait(10)
            end
        end
 
        currentEventModel = nil
        lastEventPosition = nil
    end)
end

-- ===============================
-- GUI (SIRENX STYLE)
-- ===============================

Events:AddDropdown({
    Title = "Select Target Event",
    Content = "Choose event to auto teleport",
    Options = eventsList,
    Default = nil,
    Callback = function(value)
        autoEventTargetName = value
        currentEventModel = nil
        lastEventPosition = nil
        if autoEventTeleportState and value then
            FindAndTeleportToTargetEvent()
            RestartAutoTeleportLoop()
        end
    end
})

Events:AddToggle({
    Title = "Auto Teleport Event",
    Content = "Automatically teleport & follow event",
    Default = false,
    Callback = function(state)
        if state and not autoEventTargetName then
            return false
        end
 
        autoEventTeleportState = state

        if state then
            -- Simpan lokasi terakhir
            SaveLastLocation()
            -- Enable walk on water
            EnableWalkOnWater()
            -- Langsung teleport ke event
            FindAndTeleportToTargetEvent()
            -- Mulai loop auto follow
            RestartAutoTeleportLoop()
        else
            DisableWalkOnWater()
 
            -- Hentikan loop
            if autoEventTeleportThread then
                task.cancel(autoEventTeleportThread)
                autoEventTeleportThread = nil
            end
 
            -- Kembali ke lokasi terakhir
            ReturnToLastLocation()
            currentEventModel = nil
            lastEventPosition = nil
        end
    end
})

-- Cleanup
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if autoEventTeleportState then
        EnableWalkOnWater()
    end
end)
 
LocalPlayer.CharacterRemoving:Connect(function()
    autoEventTeleportState = false
 
    if autoEventTeleportThread then
        task.cancel(autoEventTeleportThread)
        autoEventTeleportThread = nil
    end
 
    DisableWalkOnWater()
end)

local Plyr = Tabs.Teleport:AddSection("Teleports Player")

local function GetPlayerNames()
  local Names = {}
  for _, Plr in pairs(svc.Players:GetPlayers()) do
    if Plr ~= player then
      table.insert(Names, Plr.Name)
    end
  end
  return Names
end

local PlayerList = Plyr:AddDropdown({
  Title = "Select Player",
  Content = "Select a player to teleport to",
  Options = GetPlayerNames(),
  Default = nil,
  Callback = function(value)
    st.teleport.player = value
  end
})

Plyr:AddButton({
  Title = "Refresh Player List",
  Callback = function()
    PlayerList:SetValues(GetPlayerNames(), st.teleport.player)
    sirenx("Player list refreshed.")
  end,
  SubTitle = "Go to Player",
  SubCallback = function()
    TargetPlayer = svc.Players:FindFirstChild(st.teleport.player)
    if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("HumanoidRootPart") then
      st.char:PivotTo(TargetPlayer.Character:GetPivot())
      sirenx("Teleported to " .. TargetPlayer.Name)
    end
  end
})

--//======================================================
--// AUTO ADMIN EVENT (GUI MATCH)
--//======================================================

local player = game:GetService("Players").LocalPlayer

local AdminEventSection = Tabs.Automation:AddSection("Auto Admin Event")

-- STATUS PARAGRAPH
local countdownParagraph = AdminEventSection:AddParagraph({
    Title = "Ancient Lochness Monster",
    Content = "Waiting for event..."
})

-- STATE
local autoEventEnabled = false
local farmPosition = nil

-- GET COUNTDOWN LABEL
local function getCountdownLabel()
    local ok, label = pcall(function()
        return workspace["!!! DEPENDENCIES"]["Event Tracker"].Main.Gui.Content.Items.Countdown.Label
    end)
    return ok and label or nil
end

-- TELEPORT POS
local LOCHNESS_POS = CFrame.new(6063, -586, 4715)

local function goToEvent()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = LOCHNESS_POS
    end
end

local function returnToFarm()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp and farmPosition then
        hrp.CFrame = farmPosition
    end
end

-- TOGGLE AUTO EVENT
AdminEventSection:AddToggle({
    Title = "Auto Lochness Event",
    Default = false,
    Callback = function(state)
        autoEventEnabled = state

        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if state then
            farmPosition = hrp.CFrame
        else
            returnToFarm()
        end
    end
})

-- COUNTDOWN LOOP (ALWAYS RUN)
task.spawn(function()
    local label = getCountdownLabel()

    while true do
        task.wait(1)

        if not label or not label.Parent then
            label = getCountdownLabel()
        end

        local text = label and label.Text or ""

        if text == "" then
            countdownParagraph:SetContent("Waiting for countdown...")
        else
            countdownParagraph:SetContent("Timer: " .. text)
        end

        if autoEventEnabled and text ~= "" then
            local h, m, s = text:match("(%d+)H%s*(%d+)M%s*(%d+)S")
            h, m, s = tonumber(h), tonumber(m), tonumber(s)

            if h == 3 and m == 59 and s == 59 then
                goToEvent()
            elseif h == 3 and m == 49 and s == 59 then
                returnToFarm()
            end
        end
    end
end)

--//======================================================
--// AUTO CHRISTMAS CAVE (WIB)
--//======================================================

AdminEventSection:AddDivider()

local CHRISTMAS_CAVE_POS =
    CFrame.new(541.647, -580.581, 8902.609)
    * CFrame.Angles(0, -1.728958, 0)

local ChristmasSchedule = {
    "01:00","02:30","04:00","05:30","07:00","08:30",
    "10:00","11:30","13:00","14:30","16:00","17:30",
    "19:00","20:30","22:00","23:30"
}

local autoChristmas = false
local lastPos = nil
local inCave = false
local loopThread = nil

local statusParagraph = AdminEventSection:AddParagraph({
    Title = "Christmas Cave Status",
    Content = "Waiting for schedule..."
})

-- TIME HELPERS
local function getWIB()
    local t = os.date("!*t")
    return (t.hour + 7) % 24, t.min, t.sec
end

local function timeToSec(t)
    local h, m = t:match("(%d+):(%d+)")
    return h * 3600 + m * 60
end

-- TELEPORT
local function goCave()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        if not inCave then lastPos = hrp.CFrame end
        hrp.CFrame = CHRISTMAS_CAVE_POS
        inCave = true
    end
end

local function returnBack()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp and lastPos then
        hrp.CFrame = lastPos
        inCave = false
    end
end

-- MAIN LOOP
local function caveLoop()
    while autoChristmas do
        local h, m, s = getWIB()
        local nowSec = h * 3600 + m * 60 + s

        for i = 1, #ChristmasSchedule, 2 do
            local startS = timeToSec(ChristmasSchedule[i])
            local endS = timeToSec(ChristmasSchedule[i+1])

            if nowSec >= startS and nowSec <= endS then
                if not inCave then goCave() end
                break
            else
                if inCave then returnBack() end
            end
        end

        statusParagraph:SetContent(
            string.format("WIB Time: %02d:%02d:%02d", h, m, s)
        )

        task.wait(1)
    end

    if inCave then returnBack() end
end

-- TOGGLE
AdminEventSection:AddToggle({
    Title = "Auto Christmas Cave (WIB)",
    Default = false,
    Callback = function(state)
        autoChristmas = state

        if state then
            loopThread = task.spawn(caveLoop)
        else
            if loopThread then
                task.cancel(loopThread)
                loopThread = nil
            end
        end
    end
})

-- BUTTONS
AdminEventSection:AddButton({
    Title = "Teleport Now",
    Callback = goCave
})

AdminEventSection:AddButton({
    Title = "Return to Position",
    Callback = returnBack
})

-- Cleanup
player.CharacterRemoving:Connect(function()
    autoChristmasCave = false
    if checkThread then
        task.cancel(checkThread)
        checkThread = nil
    end
end)
 
-- Auto reconnect jika character mati
player.CharacterAdded:Connect(function()
    task.wait(2)
    if autoChristmasCave then
        checkThread = task.spawn(startCheckLoop)
    end
end)

local Sirenx = loadstring(game:HttpGet("https://raw.githubusercontent.com/rendy45kz/vir/refs/heads/main/aegishub.lua"))()

local Window = Sirenx:Window({
  Title   = "AegisHUB |",
  Footer  = "Fish It",
  Image   = "85286478652862",
  Color   = Color3.fromRGB(244, 244, 245),
  Theme   = 129648704071138,
  Version = 1,
})

local svc = {
  Players     = game:GetService("Players"),
  RunService  = game:GetService("RunService"),
  HttpService = game:GetService("HttpService"),
  RS          = game:GetService("ReplicatedStorage"),
  VU          = game:GetService("VirtualUser"),
  VIM         = game:GetService("VirtualInputManager"),
  PG          = game:GetService("Players").LocalPlayer.PlayerGui,
  Camera      = workspace.CurrentCamera,
  GuiService  = game:GetService("GuiService"),
  CoreGui     = game:GetService("CoreGui"),
  Stats       = game:GetService("Stats"),
  TpService   = game:GetService("TeleportService"),
  Starter     = game:GetService("StarterPlayer"),
  UIS         = game:GetService("UserInputService"),
}

_G.httpRequest =
  (syn and syn.request)
  or (http and http.request)
  or http_request
  or (fluxus and fluxus.request)
  or request
if not _G.httpRequest then
  return
end

local player = svc.Players.LocalPlayer
local function getHRP()
  local char = player.Character or player.CharacterAdded:Wait()
  return char:WaitForChild("HumanoidRootPart")
end
local function getHumanoid()
  local char = player.Character or player.CharacterAdded:Wait()
  return char:WaitForChild("Humanoid")
end

local BaseFolder           = "AegisHub"
local PositionFile         = BaseFolder .. "/Position.json"

local gui = {
  Merchant        = svc.PG.Merchant,
  MerchantRoot    = svc.PG.Merchant.Main.Background,
  ItemsFrame      = svc.PG.Merchant.Main.Background.Items.ScrollingFrame,
  RefreshMerchant = svc.PG.Merchant.Main.Background.RefreshLabel,
}

local mods = {
  Net                     = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
  Replion                 = require(svc.RS.Packages.Replion),
  FishingController       = require(svc.RS.Controllers.FishingController),
  NotificationController  = require(svc.RS.Controllers.NotificationController),
  AnimationController     = require(svc.RS.Controllers.AnimationController),
  CutsceneController      = require(svc.RS.Controllers.CutsceneController),
  TradingController       = require(svc.RS.Controllers.ItemTradingController),
  ItemUtility             = require(svc.RS.Shared.ItemUtility),
  VendorUtility           = require(svc.RS.Shared.VendorUtility),
  CutsceneUtility         = require(svc.RS.Shared.CutsceneUtility),
  PlayerStatsUtility      = require(svc.RS.Shared.PlayerStatsUtility),
  Effects                 = require(svc.RS.Shared.Effects),
  NotifierFish            = require(svc.RS.Controllers.TextNotificationController),
  InputControl            = require(svc.RS.Modules.InputControl),
  VFX                     = require(svc.RS.Controllers.VFXController)
}

local api = {
  Events = {
    RECutscene                    = mods.Net["RE/ReplicateCutscene"],
    REStop                        = mods.Net["RE/StopCutscene"],
    REFav                         = mods.Net["RE/FavoriteItem"],
    REFavChg                      = mods.Net["RE/FavoriteStateChanged"],
    REFishDone                    = mods.Net["RE/FishingCompleted"],
    REFishGot                     = mods.Net["RE/FishCaught"],
    RENotify                      = mods.Net["RE/TextNotification"],
    REEquip                       = mods.Net["RE/EquipToolFromHotbar"],
    REEquipItem                   = mods.Net["RE/EquipItem"],
    REAltar                       = mods.Net["RE/ActivateEnchantingAltar"],
    REAltar2                      = mods.Net["RE/ActivateSecondEnchantingAltar"],
    UpdateOxygen                  = mods.Net["URE/UpdateOxygen"],
    REPlayFishEffect              = mods.Net["RE/PlayFishingEffect"],
    RETextEffect                  = mods.Net["RE/ReplicateTextEffect"],
    REEvReward                    = mods.Net["RE/ClaimEventReward"],
    Totem                         = mods.Net["RE/SpawnTotem"],
    REObtainedNewFishNotification = mods.Net["RE/ObtainedNewFishNotification"],
    FishingMinigameChanged        = mods.Net["RE/FishingMinigameChanged"],
    FishingStopped                = mods.Net["RE/FishingStopped"],
  },

  Functions = {
    Trade       = mods.Net["RF/InitiateTrade"],
    BuyRod      = mods.Net["RF/PurchaseFishingRod"],
    BuyBait     = mods.Net["RF/PurchaseBait"],
    BuyWeather  = mods.Net["RF/PurchaseWeatherEvent"],
    ChargeRod   = mods.Net["RF/ChargeFishingRod"],
    StartMini   = mods.Net["RF/RequestFishingMinigameStarted"],
    UpdateRadar = mods.Net["RF/UpdateFishingRadar"],
    Cancel      = mods.Net["RF/CancelFishingInputs"],
    Dialogue    = mods.Net["RF/SpecialDialogueEvent"],
    SellItem    = mods.Net["RF/SellItem"],
    SellAllItem = mods.Net["RF/SellAllItems"],
    AutoEnabled = mods.Net["RF/UpdateAutoFishingState"]
  }
}

local st                   = {
  player           = player,
  walk             = false,
  walkSpeed        = 16,
  infiniteJump     = false,
  hideIdentity     = false,
  hideNames        = "AegisHUB",
  hideLevels       = "---------",
  char             = player.Character or player.CharacterAdded:Wait(),
  menuRings        = workspace:WaitForChild("!!! MENU RINGS"),
  zones            = workspace:WaitForChild("Zones"),
  vim              = svc.VIM,
  cam              = svc.Camera,
  fishingLegit     = false,
  minigameDelay    = 0.1,
  autoFishing      = false,
  completeDelay    = 0.5,
  instantFishing   = false,

  teleport = {
    island = nil,
    event  = nil,
    player = nil,
  },
  shop = {
    weather       = {},
    autoWeather   = false,
  },
  sell = {
    enabled = false,
    caughtTarget = 100,
    enchantEnabled = false,
    _sellThread = nil,
},
  market = {
    autoSellThreshold = "Legendary",
    sellAtAmount      = 500,
    autoSell          = false,
    enchSellAt        = 100,
    enchSell          = false,
  },
  favorite = {
    auto             = false,
    names            = {},
    rarities         = {},
    mutations        = {},
  },
  hide = {
    notifications   = false,
    cutscenes       = false,
    animations      = false,
    vfx             = false,
  },
  quest = {
    autoDeepSea      = false,
    autoElement      = false,
    autoQuestFlow    = false,
    triggerRuin      = false,
    autoClassicEvent = false,
  },

  perfection = {
    activated = false,   -- toggle manual
    enabled = false,     -- state internal
    autoByInstant = false,
}
}
local ConnectionWalkSpeed = nil
local antiAfkConnection = nil
local oldRequestCharge = nil

local function EnablePerfection()
    if st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(true)
    end)

    pcall(function()
        if not oldRequestCharge then
            oldRequestCharge = mods.FishingController.RequestChargeFishingRod
        end
        mods.FishingController.RequestChargeFishingRod = function()
            return nil
        end
    end)

    st.perfection.enabled = true
end

local function DisablePerfection()
    if not st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(false)
    end)

    pcall(function()
        if oldRequestCharge then
            mods.FishingController.RequestChargeFishingRod = oldRequestCharge
            oldRequestCharge = nil
        end
    end)

    st.perfection.enabled = false
end


st.player.CharacterAdded:Connect(function(char)
  st.char = char
end)

local repl = {
  Data = mods.Replion.Client:WaitReplion("Data"),
  Items = svc.RS:WaitForChild("Items"),
  Variants = svc.RS:WaitForChild("Variants"),
  PlayerStat = require(svc.RS.Packages._Index:FindFirstChild("ytrev_replion@2.0.0-rc.3").replion)
}

player.Idled:Connect(function()
	svc.VU:CaptureController()
	svc.VU:ClickButton2(Vector2.zero)
	st.vim:SendKeyEvent(true, Enum.KeyCode.RightMeta, false, game)
	st.vim:SendKeyEvent(false, Enum.KeyCode.RightMeta, false, game)
end)

local Tabs = {
  Info = Window:AddTab({ Name = "Info", Icon = "player" }),
  Player = Window:AddTab({ Name = "Player", Icon = "user" }),
  Fishing = Window:AddTab({ Name = "Fishing", Icon = "fish" }),
  Shop = Window:AddTab({ Name = "Shop", Icon = "shop" }),
  Automation = Window:AddTab({ Name = "Automation", Icon = "next" }),
  Teleport = Window:AddTab({ Name = "Teleport", Icon = "gps" }),
  Misc = Window:AddTab({ Name = "Misc", Icon = "settings" }),
}

InfoSection = Tabs.Info:AddSection("Information", true)

InfoSection:AddParagraph({
  Title = "Join Whatsapp Server",
  Content = "Join Us!",
  Icon = "whatsapp",
  ButtonText = "Copy Whatsapp Link",
  ButtonCallback = function()
    local link = "https://chat.whatsapp.com/DU81SA1xaoiA5nOvxAr5OR"
    if setclipboard then
      setclipboard(link)
      sirenx("Successfully Copied!")
    end
  end
})

ServerSection = Tabs.Info:AddSection("Server")

local CurrentServer = ServerSection:AddParagraph({
  Title = "Current Server",
  Content = [[
Ping: 0 ms | FPS: 0/s | Players: 0/0
  ]],
  Icon = "stat",
})

task.spawn(function()
  while task.wait(1) do
    CurrentServer:SetContent(
      string.format([[
Ping: %d ms | FPS: %d/s | Players: %d/%d
      ]],
        math.floor(svc.Stats.PerformanceStats.Ping:GetValue() + 0.5),
        math.floor(1 / svc.RunService.RenderStepped:Wait() + 0.5),
        #svc.Players:GetPlayers(),
        svc.Players.MaxPlayers
      )
    )
  end
end)

ServerSection:AddButton({
  Title = "Rejoin Server",
  Content = "Rejoins the current server",
  Callback = function()
    sirenx("Rejoining Server...")
    svc.TpService:Teleport(game.PlaceId, player)
  end
})

Plyrs = Tabs.Player:AddSection("Player")

Plyrs:AddToggle({
  Title = "Enable",
  Content = "Enable Walk Speed Changer",
  Default = false,
  Callback = function(state)
    st.walk = state

    if ConnectionWalkSpeed then
      ConnectionWalkSpeed:Disconnect()
      ConnectionWalkSpeed = nil
    end

    if state then
      local hum = getHumanoid()
      hum.WalkSpeed = st.walkSpeed
      ConnectionWalkSpeed = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if st.walk and hum.WalkSpeed ~= st.walkSpeed then
          hum.WalkSpeed = st.walkSpeed
        end
      end)
    else
      getHumanoid().WalkSpeed = svc.Starter.CharacterWalkSpeed
    end
  end
})

Plyrs:AddSlider({
  Title = "Walk Speed",
  Content = "Change your walk speed",
  Min = 16,
  Max = 500,
  Increment = 1,
  Default = st.walkSpeed,
  Callback = function(value)
    st.walkSpeed = value
    if st.walk then
      getHumanoid().WalkSpeed = value
    end
  end
})

Plyrs:AddToggle({
  Title = "Infinite Jump",
  Content = "Allows you to jump infinitely",
  Default = false,
  Callback = function(state)
    st.infiniteJump = state
    if state then
      svc.UIS.JumpRequest:Connect(function()
        if st.infiniteJump then
          local hum = getHumanoid()
          hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
      end)
    end
  end
}, "InfiniteJump")

local Connections = {}
local OriginalText = {}
local DescendantAddedConnection = nil

local function HandleUsernameChange(Object)
	if not st.hideIdentity or not (Object:IsA("TextLabel") or Object:IsA("TextBox") or Object:IsA("TextButton")) then
		return
	end

	if not Connections[Object] then
		Connections[Object] = Object:GetPropertyChangedSignal("Text"):Connect(function()
			HandleUsernameChange(Object)
		end)
	end

	local text = Object.Text
	if text:find(st.player.Name) or text:find(st.player.DisplayName) then
		OriginalText[Object] = text
		Object.Text = text:gsub(st.player.Name, st.hideNames):gsub(st.player.DisplayName, st.hideNames)
	end
end

Plyrs:AddInput({
  Title = "Set Name",
  Content = "Sets the name to replace your username with",
  Default = st.hideNames,
  Placeholder = st.hideNames,
  Callback = function(value)
    st.hideNames = value
  end
})

Plyrs:AddInput({
  Title = "Set Level Text",
  Content = "Sets the text to replace your level with",
  Default = st.hideLevels,
  Placeholder = st.hideLevels,
  Callback = function(value)
    st.hideLevels = value
  end
})

Plyrs:AddToggle({
	Title = "Hide Identity",
	Content = "Hides your player identity locally",
	Default = false,
	Callback = function(state)
		st.hideIdentity = state

		if state then 
			if DescendantAddedConnection then
				DescendantAddedConnection:Disconnect()
			end

			for i,v in pairs(game:GetDescendants()) do
				pcall(function()
					HandleUsernameChange(v)
				end)
			end

			pcall(function()
				local label = st.char.HumanoidRootPart.Overhead.LevelContainer.Label
				if label and not OriginalText[label] then
					OriginalText[label] = label.Text
				end
				label.Text = st.hideLevels
			end)

			DescendantAddedConnection = game.DescendantAdded:Connect(function(v)
				pcall(function()
					HandleUsernameChange(v)
				end)
			end)
		else
			if DescendantAddedConnection then
				DescendantAddedConnection:Disconnect()
				DescendantAddedConnection = nil
			end

			for Object, Connection in pairs(Connections) do
				if Connection then
					Connection:Disconnect()
				end
			end
			Connections = {}

			if OriginalText then
				for Object, Text in pairs(OriginalText) do
					if Object and Object.Parent then
						pcall(function()
							Object.Text = Text
						end)
					end
				end
				OriginalText = {}
			end
		end
	end
})

Camera = Tabs.Player:AddSection("Camera")

Camera:AddToggle({
  Title = "Max Zoom",
  Content = "Allows you to zoom out the furthest",
  Default = false,
  Callback = function(state)
    ConnectionZoom = ConnectionZoom or nil

    if ConnectionZoom then
      ConnectionZoom:Disconnect()
      ConnectionZoom = nil
    end

    if state then
      st.player.CameraMaxZoomDistance = 50000
      ConnectionZoom = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
        if st.player.CameraMaxZoomDistance ~= 50000 then
          st.player.CameraMaxZoomDistance = 50000
        end
      end)
    else
      st.player.CameraMaxZoomDistance = svc.Starter.CameraMaxZoomDistance
    end
  end
})

local LegitFishing = Tabs.Fishing:AddSection("Legit Fishing")

LegitFishing:AddToggle({
  Title = "Legit Fishing",
  Content = "Automatically fishes for you",
  Default = false,
  Callback = function(state)
    st.fishingLegit = state

    task.spawn(function()
      while st.fishingLegit do
        local GUID = mods.FishingController:GetCurrentGUID()

        if GUID then
          task.wait(st.MinigameDelay)
          api.Events.REFishDone:FireServer()
        elseif not mods.FishingController:OnCooldown() then
          api.Functions.Cancel:InvokeServer()
          mods.FishingController:RequestChargeFishingRod(nil, true)
        end
        task.wait(0.1)
      end
    end)
  end
})

local MD = LegitFishing:AddInput({
  Title = "Minigame Delay",
  Content = "Delay for finish the minigame",
  Default = tostring(st.minigameDelay),
  Placeholder = "0.1",
  Callback = function(value)
    local num = tonumber(value)
    if not num or num < 0 or num > 5 then
      task.spawn(function()
        task.wait(st.minigameDelay)
        sirenx("Invalid number! Must be between 0 and 5.")
      end)
    end
    st.MinigameDelay = num
  end
})

local AutoFishing = Tabs.Fishing:AddSection("Instant Fishing")

api.Events.RETextEffect.OnClientEvent:Connect(function(data)
  if not (data and data.TextData and data.TextData.EffectType == "Exclaim") then return end
  if not (st.char and data.Container == st.char:FindFirstChild("Head")) then return end

  if st.autoFishing then
    task.delay(st.completeDelay, function()
      pcall(api.Events.REFishDone.FireServer, api.Events.REFishDone)
    end)
  end
end)

AutoFishing:AddToggle({
  Title = "Instant Fishing",
  Content = "Automatically fishes for you",
  Default = false,
  Callback = function(state)
    st.autoFishing = state

    task.spawn(function()
      api.Functions.AutoEnabled:InvokeServer(state)
      while st.autoFishing do
        api.Functions.ChargeRod:InvokeServer()
        api.Functions.StartMini:InvokeServer(-1, 0.999, workspace:GetServerTimeNow())
        task.wait(0.5)
      end
    end)
  end
})

local CD = AutoFishing:AddInput({
  Title = "Complete Delay",
  Content = "Delay for complete fishing",
  Default = tostring(st.completeDelay),
  Callback = function(value)
    local num = tonumber(value)
    if not num or num < 0 or num > 5 then
      task.spawn(function()
        task.wait()
        CD:Set(tostring(st.completeDelay))
        sirenx("Invalid number! Must be between 0 and 5.")
      end)
    end
    st.completeDelay = num
  end
})

local Fish2 = Tabs.Fishing:AddSection("Blatant Fishing")

Fish2:AddToggle({
    Title = "Perfection Support",
    Content = "Enable perfection & block rod charging",
    Default = false,
    Callback = function(state)
        st.perfection.activated = state

        if state then
            EnablePerfection()
        else
            -- jangan matikan jika Instant Fishing aktif
            if not st.perfection.autoByInstant then
                DisablePerfection()
            end
        end
    end
})


function Fastest()
  task.spawn(function()
    pcall(function() api.Functions.Cancel:InvokeServer() end)
    local now = workspace:GetServerTimeNow()
    pcall(function() api.Functions.ChargeRod:InvokeServer(now) end)
    pcall(function() api.Functions.StartMini:InvokeServer(-1, 0.999) end)
    task.wait(_G.FishingDelay)
    pcall(function() api.Events.REFishDone:FireServer() end)
  end)
end

Fish2:AddInput({
  Title = "Delay Reel",
  Value = tostring(_G.Reel),
  Default = "1.9",
  Callback = function(v)
    local n = tonumber(v)
    if n and n > 0 then _G.Reel = n end
    SaveConfig()
  end
})

Fish2:AddInput({
  Title = "Delay Fishing",
  Value = tostring(_G.FishingDelay),
  Default = "1.1",
  Callback = function(v)
    local n = tonumber(v)
    if n and n > 0 then _G.FishingDelay = n end
    SaveConfig()
  end
})

Fish2:AddToggle({
  Title = "Blatant Fishing",
  Default = _G.FBlatant,
  Callback = function(s)
    _G.FBlatant = s
    api.Functions.AutoEnabled:InvokeServer(s)

    if s then
        -- AUTO ENABLE PERFECTION
        st.perfection.autoByInstant = true
        EnablePerfection()

        st.player:SetAttribute("Loading", nil)

        task.spawn(function()
            while _G.FBlatant do
                Fastest()
                task.wait(_G.Reel)
            end
        end)
    else
        st.player:SetAttribute("Loading", false)

        -- AUTO DISABLE (jika manual OFF)
        st.perfection.autoByInstant = false
        if not st.perfection.activated then
            DisablePerfection()
        end
    end
  end
})

Fish2:AddButton({
  Title = "Recovery Fishing",
  Callback = function()
    task.spawn(function()
      pcall(function()
        api.Functions.Cancel:InvokeServer()
      end)
      local lp = game:GetService("Players").LocalPlayer
      lp:SetAttribute("Loading", nil)
      task.wait(0.05)
      lp:SetAttribute("Loading", false)
      sirenx("Recovery Successfully!")
    end)
  end
})

--//======================================================
--// ULTRA BLATANT FISHING
--//======================================================

local UltraBlatant = {
    Active = false,
    CompleteDelay = 0.7,
    CancelDelay = 0.3,
    Thread = nil
}

-- SAFE CALL
local function SafeCall(fn)
    task.spawn(function()
        pcall(fn)
    end)
end

-- CAST FUNCTION
local function UltraCast()
    local t = workspace:GetServerTimeNow()

    -- Charge Rod
    SafeCall(function()
        api.Functions.ChargeRod:InvokeServer(t)
    end)

    task.wait(0.01)

    -- Start Minigame
    SafeCall(function()
        api.Functions.StartMini:InvokeServer(-1, 0.999)
    end)
end

-- MAIN LOOP
local function UltraLoop()
    while UltraBlatant.Active do
        -- Cast
        UltraCast()

        -- Wait Complete
        task.wait(UltraBlatant.CompleteDelay)

        -- Finish Fishing
        if UltraBlatant.Active then
            SafeCall(function()
                api.Events.REFishDone:FireServer()
            end)
        end

        -- Cancel Delay
        task.wait(UltraBlatant.CancelDelay)

        -- Cancel Input
        if UltraBlatant.Active then
            SafeCall(function()
                api.Functions.Cancel:InvokeServer()
            end)
        end
    end
end

--======================================================
-- GUI SECTION
--======================================================

local UltraSection = Tabs.Fishing:AddSection("Blatant Fishing BETA")

UltraSection:AddToggle({
    Title = "Ultra Blatant Fishing",
    Content = "Extremely fast & aggressive fishing",
    Default = false,
    Callback = function(state)
        UltraBlatant.Active = state

        if state then
            -- Auto enable perfection (AMAN)
            st.perfection.autoByInstant = true
            EnablePerfection()

            -- Equip rod
            SafeCall(function()
                api.Events.REEquip:FireServer(1)
            end)

            task.wait(0.2)

            UltraBlatant.Thread = task.spawn(UltraLoop)
        else
            UltraBlatant.Active = false

            -- Cancel safely
            SafeCall(function()
                api.Functions.Cancel:InvokeServer()
            end)

            -- Jangan matikan perfection kalau manual ON
            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})

UltraSection:AddInput({
    Title = "Complete Delay",
    Content = "Delay before fish completed",
    Default = tostring(UltraBlatant.CompleteDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then
            UltraBlatant.CompleteDelay = n
        end
    end
})

UltraSection:AddInput({
    Title = "Cancel Delay",
    Content = "Delay before cancel input",
    Default = tostring(UltraBlatant.CancelDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then
            UltraBlatant.CancelDelay = n
        end
    end
})


local SellGroup = Tabs.Fishing:AddSection("Auto Selling")

local function GetCaughtCount()
    local pg = player:FindFirstChild("PlayerGui")
    if not pg then return 0 end

    local inv = pg:FindFirstChild("Inventory")
    if not inv then return 0 end

    local label = inv.Main.Top.Options.Fish.Label:FindFirstChild("BagSize")
    if not (label and label:IsA("TextLabel")) then return 0 end

    local cur = label.Text:match("(%d+)%s*/")
    return tonumber(cur) or 0
end

SellGroup:AddButton({
    Title = "Sell All",
    Callback = function()
        pcall(function()
            api.Functions.SellAllItem:InvokeServer()
        end)
    end
})

SellGroup:AddInput({
    Title = "Sell When Caught â‰¥",
    Placeholder = "ex: 100",
    Numeric = true,
    Callback = function(v)
        st.sell.caughtTarget = tonumber(v) or 0
    end
})

SellGroup:AddToggle({
    Title = "Auto Sell by Caught",
    Default = false,
    Callback = function(state)
        st.sell.enabled = state

        if st.sell._sellThread then
            task.cancel(st._sellThread)
            st._sellThread = nil
        end

        if not state then
            st.sell.caughtStart = nil
            return
        end

        -- SIMPAN JUMLAH SAAT TOGGLE ON
        st.sell.caughtStart = GetCaughtCount()

        st._sellThread = task.spawn(function()
            while st.sell.enabled do

                local current = GetCaughtCount()
                local gained = current - st.sell.caughtStart

                if gained >= st.sell.caughtTarget then
                    pcall(function()
                        api.Functions.SellAllItem:InvokeServer()
                    end)

                    -- RESET HITUNGAN SETELAH SELL
                    st.sell.caughtStart = GetCaughtCount()
                    task.wait(1.5)
                else
                    task.wait(0.5)
                end
            end
        end)
    end
})


SellGroup:AddSubSection("Auto Sell Enchant Stone")

local function GetEnchantStoneCount()
    if not (repl and repl.Data and repl.Data.Data and repl.Data.Data.Inventory) then
        return 0
    end

    local total = 0

    for _, item in pairs(repl.Data.Data.Inventory.Items) do
        if item.Id == 10 then
            -- PRIORITAS STACK
            if typeof(item.Stack) == "number" then
                total += item.Stack
            elseif typeof(item.Amount) == "number" then
                total += item.Amount
            elseif typeof(item.Quantity) == "number" then
                total += item.Quantity
            elseif typeof(item.Count) == "number" then
                total += item.Count
            else
                total += 1 -- fallback
            end
        end
    end

    return total
end

local function GetEnchantStackCount()
    local stacks = 0
    for _, item in pairs(repl.Data.Data.Inventory.Items) do
        if item.Id == 10 then
            stacks += 1
        end
    end
    return stacks
end


local EnchantStock = SellGroup:AddParagraph({
  Title = "Enchant Stone Count",
  Content = "0 Enchant Stones"
})

task.spawn(function()
  while task.wait(3) do
    EnchantStock:SetContent(
        string.format("x%d Enchant Stones", GetEnchantStoneCount())
    )
  end
end)


local TAL = SellGroup:AddInput({
    Title = "Target Stack Left",
    Content = "How many enchant stone stacks to keep",
    Default = tostring(st.market.enchSellAt),
    Callback = function(value)
        local num = tonumber(value)
        if not num or num < 0 then
            task.spawn(function()
                task.wait()
                TAL:Set(tostring(st.market.enchSellAt))
                sirenx("Invalid number! Must be 0 or higher.")
            end)
            return
        end
        st.market.enchSellAt = math.floor(num)
    end
})


SellGroup:AddToggle({
    Title = "Auto Sell Enchant Stone",
    Default = false,
    Callback = function(state)
        st.sell.enchantEnabled = state
        if not state then return end

        task.spawn(function()
            while st.sell.enchantEnabled do
                local current = GetEnchantStoneCount()
                local keep = st.market.enchSellAt or 0

                -- JANGAN JUAL JIKA SUDAH SESUAI
                if current <= keep then
                    task.wait(1)
                    continue
                end

                -- CARI 1 STACK ENCHANT STONE
                for _, item in pairs(repl.Data.Data.Inventory.Items) do
                    if item.Id == 10 then
                        pcall(function()
                            api.Functions.SellItem:InvokeServer(item.UUID)
                        end)
                        break -- JUAL 1 STACK SAJA
                    end
                end

                -- tunggu inventory update
                task.wait(1.2)
            end
        end)
    end
})


local Favorites = Tabs.Fishing:AddSection("Favorites")

local function IsFavorited(UUID, items)
  for _, Item in pairs(items) do
    if Item.UUID == UUID then return Item.Favorited == true end
  end
  return false
end

local RarityOrder = {Common = 1, Uncommon = 2, Rare = 3, Epic = 4, Legendary = 5, Mythical = 6, Secret = 7}

local function AutoFavorite(names, rarities, mutations)
  local items = repl.Data.Data.Inventory.Items
  if not items or #items == 0 then return end

  local rarityTiers, namesList, mutationList = {}, {}, {}
  
  if rarities then
    for _, rarity in ipairs(rarities) do
      if RarityOrder[rarity] then 
        rarityTiers[RarityOrder[rarity]] = true
      end
    end
  end

  if names then for _, name in ipairs(names) do namesList[name] = true end end
  if mutations then for _, mutation in ipairs(mutations) do mutationList[mutation] = true end end

  local toFavorite = {}
  
  for _, Item in pairs(items) do
    if not Item.Favorited then
      local FishData = mods.ItemUtility:GetItemData(Item.Id)
      
      if FishData and FishData.Data then
        local data = FishData.Data
        if namesList[data.Name] or rarityTiers[data.Tier] or (Item.Metadata and Item.Metadata.VariantId and mutationList[Item.Metadata.VariantId]) then
          table.insert(toFavorite, Item.UUID)
        end
      end
    end
  end

  for i, uuid in ipairs(toFavorite) do
    task.spawn(function()
      task.wait(i * 0.05)
      api.Events.REFav:FireServer(uuid)
    end)
  end
end

local function UnAutoFavoriteAll()
  local Items = repl.Data.Data.Inventory.Items
  if not Items or #Items == 0 then return end

  for _, Item in pairs(Items) do
    if IsFavorited(Item.UUID) then
      pcall(api.Events.REFav.FireServer, api.Events.REFav, Item.UUID)
    end
  end
end

Favorites:AddDropdown({
  Title = "Auto Favorite by Rarity",
  Content = "Favorite by Fish Rarity",
  Multi = true,
  Options = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Secret"},
  Default = st.favorite.rarities,
  Callback = function(value)
    st.favorite.rarities = value
  end
})

local cachedFishNames = nil
local function GetFishNames()
  if cachedFishNames then return cachedFishNames end
  
  local Names = {}
  for _, Item in pairs(repl.Items:GetChildren()) do
    local FishData = mods.ItemUtility:GetItemData(Item.Name)
    if FishData and FishData.Data and FishData.Data.Type == "Fish" then
      table.insert(Names, FishData.Data.Name)
    end
  end
  cachedFishNames = Names
  return Names
end

Favorites:AddDropdown({
  Title = "Auto Favorite by Name",
  Content = "Favorite by Fish Name",
  Multi = true,
  Options = GetFishNames(),
  Default = st.favorite.names,
  Callback = function(value)
    st.favorite.names = value
  end
})

local cachedMutations = nil
local function GetFishMutation()
  if cachedMutations then return cachedMutations end
  
  local Names = {}
  for _, Item in pairs(repl.Variants:GetChildren()) do
    table.insert(Names, Item.Name)
  end
  cachedMutations = Names
  return Names
end

Favorites:AddDropdown({
  Title = "Auto Favorite by Mutation",
  Content = "Favorite by Fish Mutation",
  Multi = true,
  Options = GetFishMutation(),
  Default = st.favorite.mutations,
  Callback = function(value)
    st.favorite.mutations = value
  end
})

Favorites:AddToggle({
  Title = "Auto Favorite",
  Content = "Automatically favorites fish for you",
  Default = false,
  Callback = function(state)
    st.favorite.auto = state

    task.spawn(function()
      while st.favorite.auto do
        AutoFavorite(st.favorite.names, st.favorite.rarities, st.favorite.mutations)
        task.wait(2)
      end
    end)
  end
})

Favorites:AddButton({
  Title = "Unfavorite All",
  Content = "Unfavorites all favorited fish",
  Callback = UnAutoFavoriteAll
})

local HideFeature = Tabs.Misc:AddSection("Hide Features")

HideFeature:AddToggle({
    Title = "Anti AFK",
    Content = "Prevents you from being kicked for idling",
    Default = true, -- ðŸ”¥ AUTO ON
    Callback = function(state)
        local VirtualUser = game:GetService("VirtualUser")

        if state then
            -- Hindari double connection
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end

            antiAfkConnection = player.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        else
            -- Matikan Anti AFK dengan benar
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
        end
    end
})

pcall(function()
  local OriginalNotif = mods.NotificationController.PlaySmallItemObtained
  mods.NotificationController.PlaySmallItemObtained = function(self, ...)
    if st.hide.notifications then return end
    return OriginalNotif(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Hide Notification",
  Content = "Hides get fishing notifications",
  Default = false,
  Callback = function(state)
    st.hide.notifications = state
  end
}, "HideNotification")

pcall(function()
  local OriginalInit = mods.CutsceneController.Init
  mods.CutsceneController.Init = function(self, ...)
    if st.hide.cutscenes then return end
    return OriginalInit(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Skip Cutscenes",
  Content = "Automatically skips fishing cutscenes",
  Default = false,
  Callback = function(state)
    st.hide.cutscenes = state
  end
}, "HideCutscenes")

pcall(function()
  local OriginalAnim = mods.AnimationController.PlayAnimation
  mods.AnimationController.PlayAnimation = function(self, ...)
    if st.hide.animations then return end
    return OriginalAnim(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Disable Animations",
  Content = "Disables fishing animations",
  Default = false,
  Callback = function(state)
    st.hide.animations = state
  end
}, "HideAnimations")

pcall(function()
  local OriginalRenderAP = mods.VFX.RenderAtPoint
  mods.VFX.RenderAtPoint = function(self, ...)
    if st.hide.vfx then return end
    return OriginalRenderAP(self, ...)
  end

  local OriginalRenderI = mods.VFX.RenderInstance
  mods.VFX.RenderInstance = function(self, ...)
    if st.hide.vfx then return end
    return OriginalRenderI(self, ...)
  end
end)

HideFeature:AddToggle({
  Title = "Disable Rod Effect",
  Content = "Hides the fishing rod bobber effect",
  Default = false,
  Callback = function(state)
    st.hide.vfx = state
  end
}, "HideVFX")

--======================================================
-- FPS BOOST SYSTEM (STABLE & CLEAN)
--======================================================

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local fpsRunning = false
local fpsConnections = {}

-- PROTECTED OBJECTS
local function IsProtected(obj)
    if obj:IsDescendantOf(player:WaitForChild("PlayerGui")) then return true end
    if obj:IsDescendantOf(game:GetService("StarterGui")) then return true end
    if obj:IsDescendantOf(game:GetService("ReplicatedStorage")) then return true end
    return false
end

-- NUKER
local function Nuke(obj)
    if not fpsRunning or IsProtected(obj) then return end

    if obj:IsA("ParticleEmitter")
    or obj:IsA("Trail")
    or obj:IsA("Beam")
    or obj:IsA("Fire")
    or obj:IsA("Smoke")
    or obj:IsA("Sparkles")
    or obj:IsA("Highlight") then
        obj:Destroy()
        return
    end

    if obj:IsA("Decal")
    or obj:IsA("Texture")
    or obj:IsA("SurfaceAppearance") then
        obj:Destroy()
        return
    end

    if obj:IsA("PointLight")
    or obj:IsA("SpotLight")
    or obj:IsA("SurfaceLight") then
        obj:Destroy()
        return
    end

    if obj:IsA("MeshPart") then
        obj.TextureID = ""
        obj.Material = Enum.Material.SmoothPlastic
        obj.Reflectance = 0
        obj.CastShadow = false
    end

    if obj:IsA("BasePart") then
        obj.Material = Enum.Material.SmoothPlastic
        obj.Color = Color3.fromRGB(170,170,170)
        obj.Reflectance = 0
        obj.CastShadow = false
    end
end

-- APPLY BOOST
local function EnableFPSBoost()
    if fpsRunning then return end
    fpsRunning = true

    -- Lighting optimize
    Lighting.GlobalShadows = false
    Lighting.FogEnd = 1e6
    Lighting.Brightness = 1
    Lighting.ClockTime = 14

    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            v:Destroy()
        end
    end

    -- Water optimize
    local terrain = Workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        terrain.WaterWaveSize = 0
        terrain.WaterWaveSpeed = 0
        terrain.WaterReflectance = 0
        terrain.WaterTransparency = 1
    end

    -- Initial nuke
    for _, v in ipairs(game:GetDescendants()) do
        Nuke(v)
    end

    -- Connections
    table.insert(fpsConnections, game.DescendantAdded:Connect(function(obj)
        task.wait()
        Nuke(obj)
    end))

    local function OnChar(char)
        for _, v in ipairs(char:GetDescendants()) do
            Nuke(v)
        end
        table.insert(fpsConnections, char.DescendantAdded:Connect(Nuke))
    end

    if player.Character then
        OnChar(player.Character)
    end

    table.insert(fpsConnections, player.CharacterAdded:Connect(OnChar))

    table.insert(fpsConnections, RunService.RenderStepped:Connect(function()
        if fpsRunning then
            settings().Rendering.QualityLevel = 1
        end
    end))
end

-- DISABLE BOOST
local function DisableFPSBoost()
    fpsRunning = false
    for _, c in ipairs(fpsConnections) do
        pcall(function() c:Disconnect() end)
    end
    fpsConnections = {}
end

--======================================================
-- GUI : FPS BOOST
--======================================================

local MiscSection = Tabs.Misc:AddSection("Performance")

MiscSection:AddToggle({
    Title = "Boost FPS",
    Content = "Reduces graphics and effects to increase performance",
    Default = false,
    Callback = function(state)
        if state then
            EnableFPSBoost()
        else
            DisableFPSBoost()
        end
    end
})

MiscSection:AddToggle({
    Title = "Disable 3D Rendering",
    Content = "Disables 3D rendering to reduce GPU usage",
    Default = false,
    Callback = function(state)
        setfpscap(60)
        if RunService.Set3dRenderingEnabled then
            RunService:Set3dRenderingEnabled(not state)
        end
    end
})


local shop = Tabs.Shop:AddSection("Merchant Shop")

local ShopMerchant = shop:AddParagraph({
  Title = "Merchant Stock Panel",
  Content = [[
- N/A
- N/A
- N/A

Next Refresh: 00H, 00M, 00S
  ]]
})

local function GetPanelItem(Panel)
  local Items = {}
  for _, Obj in ipairs(Panel:GetChildren()) do
    if Obj.Name == "Template" then
      local ItemName = Obj:FindFirstChild("Frame")
      if ItemName and ItemName:FindFirstChild("ItemName") then
        table.insert(Items, ItemName.ItemName.Text)
      end
    end
  end
  return Items
end

task.spawn(function()
  while task.wait(3) do
    local items = GetPanelItem(gui.ItemsFrame)
    ShopMerchant:SetContent(
      string.format([[
- %s
- %s
- %s

%s
      ]],
        items[1] or "N/A",
        items[2] or "N/A",
        items[3] or "N/A",
        gui.RefreshMerchant.Text
      ))
  end
end)

shop:AddButton({
  Title = "Open / Close Merchant",
  Content = "Opens or closes the merchant shop panel",
  Callback = function()
    gui.Merchant.Enabled = not gui.Merchant.Enabled
  end
})

local WeatherShop = Tabs.Shop:AddSection("Buy Weather")


WeatherShop:AddDropdown({
  Title = "Select Weather",
  Content = "Select a weather to change to",
  Multi = true,
  Options = {
    "Wind (10,000)",
    "Cloudy (20,000)",
    "Snow (15,000)",
    "Storm (35,000)",
    "Radiant (50,000)",
    "Shark Hunt (300,000)"
  },
  Default = {},
  Callback = function(value)
    st.shop.weather = value
  end
})

WeatherShop:AddToggle({
  Title = "Auto Buy Weather",
  Content = "Automatically buys selected weather effects",
  Default = false,
  Callback = function(state)
    st.shop.autoWeather = state

    task.spawn(function()
      while st.shop.autoWeather and st.shop.weather do
        for _, weather in ipairs(st.shop.weather) do
          api.Functions.BuyWeather:InvokeServer(weather:match("^(.-) %("))
        end
        task.wait(5)
      end
    end)
  end
})

local Islands= Tabs.Teleport:AddSection("Teleports Islands")

local TeleportLocations = {
  ["Fishermand Island"] = CFrame.new(251.970, 3.262, 2972.211) * CFrame.Angles(-3.141593, -1.257929, -3.141593),
	["Crater Island"] = CFrame.new(1072.845, 5.034, 5112.388) * CFrame.Angles(-0.000000, 1.229756, -0.000000),
	["Ancient Jungle"] = CFrame.new(1433.173, 6.625, -782.708) * CFrame.Angles(-0.000000, -0.360566, -0.000000),
	["Kohana"] = CFrame.new(-655.889, 17.250, 483.854) * CFrame.Angles(-0.000000, -1.567192, -0.000000),
	["Volcano"] = CFrame.new(-560.156, 17.091, 110.184) * CFrame.Angles(-0.000000, -0.530737, -0.000000),
	["Sisyphus Statue"] = CFrame.new(-3779.833, -135.074, -971.949) * CFrame.Angles(-3.141593, -1.297434, -3.141593),
	["Tropical Grove"] = CFrame.new(-2033.356, 6.268, 3679.782) * CFrame.Angles(-3.141593, 0.767602, -3.141593),
	["Treasure Room"] = CFrame.new(-3649.771, -268.340, -1666.103) * CFrame.Angles(-3.141593, -1.352865, -3.141593),
	["Sacred Temple"] = CFrame.new(1476.163, -22.125, -675.394) * CFrame.Angles(-0.000000, -1.515740, -0.000000),
	["Coral Reefs"] = CFrame.new(-3132.816, 3.354, 2129.545) * CFrame.Angles(-0.000000, -0.597924, -0.000000),
	["Weather Machine"] = CFrame.new(-1515.702, 2.875, 1912.361) * CFrame.Angles(-3.141593, -0.177870, -3.141593),
	["Esoteric Dephts"] = CFrame.new(3204.603, -1302.855, 1410.619) * CFrame.Angles(-0.000000, 0.454337, -0.000000),
	["Ancient Ruin"] = CFrame.new(6099.980, -585.924, 4682.759) * CFrame.Angles(3.141535, 1.569459, -3.141535),
	["Classic Island"] = CFrame.new(1226.521, 4.000, 2774.871) * CFrame.Angles(0.000000, 0.006386, -0.000000),
	["Iron Cavern"] = CFrame.new(-8800.321, -585.000, 83.745) * CFrame.Angles(-0.000000, -0.943772, 0.000000),
	["Iron Cafe"] = CFrame.new(-8642.318, -547.500, 158.730) * CFrame.Angles(0.000000, -1.559896, 0.000000),
	["Underground Cellar"] = CFrame.new(2135.955, -91.199, -697.068) * CFrame.Angles(-0.000000, -0.098867, 0.000000),
	["Christmas Island 1"] = CFrame.new(666.372, 5.080, 1617.845) * CFrame.Angles(0.000000, 0.793008, 0.000000),
	["Christmas Island 2"] = CFrame.new(1161.302, 23.762, 1530.955) * CFrame.Angles(0.000000, 2.861345, 0.000000)
}

local function GetNameTeleport()
  local Names = {}
  for Key,_ in pairs(TeleportLocations) do table.insert(Names, Key) end
  return Names
end

Islands:AddDropdown({
  Title = "Select Island",
  Content = "Select an island to teleport to",
  Options = GetNameTeleport(),
  Default = nil,
  Callback = function(value)
    st.teleport.island = value
  end
})

Islands:AddButton({
  Title = "Teleport",
  Content = "Teleports you to the selected island",
  Callback = function()
    local loc = TeleportLocations[st.teleport.island]
    if not loc then return end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
      hrp.CFrame = loc
      sirenx("Teleported to " .. st.teleport.island)
    end
  end
})

local Events = Tabs.Teleport:AddSection("Teleports Events")

-- ===============================
-- EVENT AUTO TELEPORT (GUI MATCH)
-- ===============================

local eventsList = { 
    "Shark Hunt",
    "Ghost Shark Hunt",
    "Worm Hunt",
    "Temporary event",
    "Ghost Worm",
    "Megalodon Hunt"

}

local autoEventTargetName = nil 
local autoEventTeleportState = false
local autoEventTeleportThread = nil
local lastLocation = nil
local currentEventModel = nil
local lastEventPosition = nil
 
-- VARIABEL WALK ON WATER
local walkOnWaterConnection = nil
local isWalkOnWater = false
local waterPlatform = nil
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = game.Players.LocalPlayer
 
-- FUNGSI SAVE LAST LOCATION (simpan ketika enable)
local function SaveLastLocation()
    local character = LocalPlayer.Character
    if not character then return false end
 
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
 
    lastLocation = hrp.CFrame
    return true
end

-- FUNGSI RETURN TO LAST LOCATION
local function ReturnToLastLocation()
    if not lastLocation then return false end
 
    local character = LocalPlayer.Character
    if not character then return false end
 
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
 
    hrp.CFrame = lastLocation
    return true
end

-- FUNGSI WALK ON WATER
local function EnableWalkOnWater()
    if isWalkOnWater then return end
 
    isWalkOnWater = true
 
    if not waterPlatform then
        waterPlatform = Instance.new("Part")
        waterPlatform.Name = "WaterPlatform"
        waterPlatform.Anchored = true
        waterPlatform.CanCollide = true
        waterPlatform.Transparency = 1 
        waterPlatform.Size = Vector3.new(15, 1, 15)
        waterPlatform.Parent = workspace
    end
 
    if walkOnWaterConnection then 
        walkOnWaterConnection:Disconnect() 
    end
 
    walkOnWaterConnection = game:GetService("RunService").RenderStepped:Connect(function()
        if not isWalkOnWater then return end
 
        local character = LocalPlayer.Character
        if not character then return end
 
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
 
        if not waterPlatform or not waterPlatform.Parent then
            waterPlatform = Instance.new("Part")
            waterPlatform.Name = "WaterPlatform"
            waterPlatform.Anchored = true
            waterPlatform.CanCollide = true
            waterPlatform.Transparency = 1 
            waterPlatform.Size = Vector3.new(15, 1, 15)
            waterPlatform.Parent = workspace
        end
 
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {workspace.Terrain} 
        rayParams.FilterType = Enum.RaycastFilterType.Include
        rayParams.IgnoreWater = false
 
        local rayOrigin = hrp.Position + Vector3.new(0, 5, 0) 
        local rayDirection = Vector3.new(0, -500, 0)
        local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
 
        if result and result.Material == Enum.Material.Water then
            local waterSurfaceHeight = result.Position.Y
            waterPlatform.Position = Vector3.new(hrp.Position.X, waterSurfaceHeight, hrp.Position.Z)
 
            if hrp.Position.Y < (waterSurfaceHeight + 2) and hrp.Position.Y > (waterSurfaceHeight - 5) then
                if not UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    hrp.CFrame = CFrame.new(hrp.Position.X, waterSurfaceHeight + 3.2, hrp.Position.Z)
                end
            end
        else
            waterPlatform.Position = Vector3.new(hrp.Position.X, -500, hrp.Position.Z)
        end
    end)
end

local function DisableWalkOnWater()
    if not isWalkOnWater then return end
 
    isWalkOnWater = false
 
    if walkOnWaterConnection then 
        walkOnWaterConnection:Disconnect() 
        walkOnWaterConnection = nil 
    end
 
    if waterPlatform then 
        waterPlatform:Destroy() 
        waterPlatform = nil 
    end
end

-- FUNGSI CARI EVENT
local function FindTargetEvent()
    if not autoEventTargetName then return nil end
 
    local searchName = autoEventTargetName
    if searchName == "Temporary event" then
        searchName = "Black Hole"
    end
 
    for _, child in pairs(workspace:GetChildren()) do
        if child.Name == "Props" then
            local eventModel = nil
 
            if searchName == "Worm Hunt" then
                eventModel = child:FindFirstChild("Model")
            else
                eventModel = child:FindFirstChild(searchName)
            end
 
            if eventModel then
                return eventModel
            end
        end
    end
 
    return nil
end

-- TELEPORT

local function TeleportToEvent(eventModel)
    if not eventModel then return false end
 
    local character = LocalPlayer.Character
    if not character then return false end
 
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
 
    local targetPos = eventModel:GetPivot().Position
    hrp.CFrame = CFrame.new(targetPos + Vector3.new(0, 15, 0))
 
    currentEventModel = eventModel
    lastEventPosition = targetPos
 
    return true
end

local function HasEventMoved()
    if not currentEventModel or not currentEventModel.Parent then
        return true
    end
 
    local currentPos = currentEventModel:GetPivot().Position
    if not lastEventPosition then return true end
 
    local distance = (currentPos - lastEventPosition).Magnitude
    return distance > 5
end

local function FollowMovingEvent()
    if not currentEventModel then return false end
 
    if not currentEventModel.Parent then
        currentEventModel = nil
        lastEventPosition = nil
        return false
    end
 
    if HasEventMoved() then
        return TeleportToEvent(currentEventModel)
    end
 
    return false
end

local function FindAndTeleportToTargetEvent()
    if not autoEventTargetName then return false end
 
    local eventModel = FindTargetEvent()
    if eventModel then
        return TeleportToEvent(eventModel)
    end
 
    return false
end
 
-- FUNGSI UNTUK RESTART AUTO TELEPORT LOOP
local function RestartAutoTeleportLoop()
    if not autoEventTeleportState then return end
 
    if autoEventTeleportThread then 
        task.cancel(autoEventTeleportThread) 
        autoEventTeleportThread = nil
    end
 
    currentEventModel = nil
    lastEventPosition = nil
 
    autoEventTeleportThread = task.spawn(function()
        while autoEventTeleportState do
            local success = FindAndTeleportToTargetEvent()
 
            if success then
                for i = 1, 180 do
                    if not autoEventTeleportState then break end
                    FollowMovingEvent()
                    task.wait(5)
                end
            else
                task.wait(10)
            end
        end
 
        currentEventModel = nil
        lastEventPosition = nil
    end)
end

-- ===============================
-- GUI (SIRENX STYLE)
-- ===============================

Events:AddDropdown({
    Title = "Select Target Event",
    Content = "Choose event to auto teleport",
    Options = eventsList,
    Default = nil,
    Callback = function(value)
        autoEventTargetName = value
        currentEventModel = nil
        lastEventPosition = nil
        if autoEventTeleportState and value then
            FindAndTeleportToTargetEvent()
            RestartAutoTeleportLoop()
        end
    end
})

Events:AddToggle({
    Title = "Auto Teleport Event",
    Content = "Automatically teleport & follow event",
    Default = false,
    Callback = function(state)
        if state and not autoEventTargetName then
            return false
        end
 
        autoEventTeleportState = state

        if state then
            -- Simpan lokasi terakhir
            SaveLastLocation()
            -- Enable walk on water
            EnableWalkOnWater()
            -- Langsung teleport ke event
            FindAndTeleportToTargetEvent()
            -- Mulai loop auto follow
            RestartAutoTeleportLoop()
        else
            DisableWalkOnWater()
 
            -- Hentikan loop
            if autoEventTeleportThread then
                task.cancel(autoEventTeleportThread)
                autoEventTeleportThread = nil
            end
 
            -- Kembali ke lokasi terakhir
            ReturnToLastLocation()
            currentEventModel = nil
            lastEventPosition = nil
        end
    end
})

-- Cleanup
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if autoEventTeleportState then
        EnableWalkOnWater()
    end
end)
 
LocalPlayer.CharacterRemoving:Connect(function()
    autoEventTeleportState = false
 
    if autoEventTeleportThread then
        task.cancel(autoEventTeleportThread)
        autoEventTeleportThread = nil
    end
 
    DisableWalkOnWater()
end)

local Plyr = Tabs.Teleport:AddSection("Teleports Player")

local function GetPlayerNames()
  local Names = {}
  for _, Plr in pairs(svc.Players:GetPlayers()) do
    if Plr ~= player then
      table.insert(Names, Plr.Name)
    end
  end
  return Names
end

local PlayerList = Plyr:AddDropdown({
  Title = "Select Player",
  Content = "Select a player to teleport to",
  Options = GetPlayerNames(),
  Default = nil,
  Callback = function(value)
    st.teleport.player = value
  end
})

Plyr:AddButton({
  Title = "Refresh Player List",
  Callback = function()
    PlayerList:SetValues(GetPlayerNames(), st.teleport.player)
    sirenx("Player list refreshed.")
  end,
  SubTitle = "Go to Player",
  SubCallback = function()
    TargetPlayer = svc.Players:FindFirstChild(st.teleport.player)
    if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("HumanoidRootPart") then
      st.char:PivotTo(TargetPlayer.Character:GetPivot())
      sirenx("Teleported to " .. TargetPlayer.Name)
    end
  end
})

--//======================================================
--// AUTO ADMIN EVENT (GUI MATCH)
--//======================================================

local player = game:GetService("Players").LocalPlayer

local AdminEventSection = Tabs.Automation:AddSection("Auto Admin Event")

-- STATUS PARAGRAPH
local countdownParagraph = AdminEventSection:AddParagraph({
    Title = "Ancient Lochness Monster",
    Content = "Waiting for event..."
})

-- STATE
local autoEventEnabled = false
local farmPosition = nil

-- GET COUNTDOWN LABEL
local function getCountdownLabel()
    local ok, label = pcall(function()
        return workspace["!!! DEPENDENCIES"]["Event Tracker"].Main.Gui.Content.Items.Countdown.Label
    end)
    return ok and label or nil
end

-- TELEPORT POS
local LOCHNESS_POS = CFrame.new(6063, -586, 4715)

local function goToEvent()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = LOCHNESS_POS
    end
end

local function returnToFarm()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp and farmPosition then
        hrp.CFrame = farmPosition
    end
end

-- TOGGLE AUTO EVENT
AdminEventSection:AddToggle({
    Title = "Auto Lochness Event",
    Default = false,
    Callback = function(state)
        autoEventEnabled = state

        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if state then
            farmPosition = hrp.CFrame
        else
            returnToFarm()
        end
    end
})

-- COUNTDOWN LOOP (ALWAYS RUN)
task.spawn(function()
    local label = getCountdownLabel()

    while true do
        task.wait(1)

        if not label or not label.Parent then
            label = getCountdownLabel()
        end

        local text = label and label.Text or ""

        if text == "" then
            countdownParagraph:SetContent("Waiting for countdown...")
        else
            countdownParagraph:SetContent("Timer: " .. text)
        end

        if autoEventEnabled and text ~= "" then
            local h, m, s = text:match("(%d+)H%s*(%d+)M%s*(%d+)S")
            h, m, s = tonumber(h), tonumber(m), tonumber(s)

            if h == 3 and m == 59 and s == 59 then
                goToEvent()
            elseif h == 3 and m == 49 and s == 59 then
                returnToFarm()
            end
        end
    end
end)

--//======================================================
--// AUTO CHRISTMAS CAVE (WIB)
--//======================================================

AdminEventSection:AddDivider()

local CHRISTMAS_CAVE_POS =
    CFrame.new(541.647, -580.581, 8902.609)
    * CFrame.Angles(0, -1.728958, 0)

local ChristmasSchedule = {
    "01:00","02:30","04:00","05:30","07:00","08:30",
    "10:00","11:30","13:00","14:30","16:00","17:30",
    "19:00","20:30","22:00","23:30"
}

local autoChristmas = false
local lastPos = nil
local inCave = false
local loopThread = nil

local statusParagraph = AdminEventSection:AddParagraph({
    Title = "Christmas Cave Status",
    Content = "Waiting for schedule..."
})

-- TIME HELPERS
local function getWIB()
    local t = os.date("!*t")
    return (t.hour + 7) % 24, t.min, t.sec
end

local function timeToSec(t)
    local h, m = t:match("(%d+):(%d+)")
    return h * 3600 + m * 60
end

-- TELEPORT
local function goCave()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        if not inCave then lastPos = hrp.CFrame end
        hrp.CFrame = CHRISTMAS_CAVE_POS
        inCave = true
    end
end

local function returnBack()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp and lastPos then
        hrp.CFrame = lastPos
        inCave = false
    end
end

-- MAIN LOOP
local function caveLoop()
    while autoChristmas do
        local h, m, s = getWIB()
        local nowSec = h * 3600 + m * 60 + s

        for i = 1, #ChristmasSchedule, 2 do
            local startS = timeToSec(ChristmasSchedule[i])
            local endS = timeToSec(ChristmasSchedule[i+1])

            if nowSec >= startS and nowSec <= endS then
                if not inCave then goCave() end
                break
            else
                if inCave then returnBack() end
            end
        end

        statusParagraph:SetContent(
            string.format("WIB Time: %02d:%02d:%02d", h, m, s)
        )

        task.wait(1)
    end

    if inCave then returnBack() end
end

-- TOGGLE
AdminEventSection:AddToggle({
    Title = "Auto Christmas Cave (WIB)",
    Default = false,
    Callback = function(state)
        autoChristmas = state

        if state then
            loopThread = task.spawn(caveLoop)
        else
            if loopThread then
                task.cancel(loopThread)
                loopThread = nil
            end
        end
    end
})

-- BUTTONS
AdminEventSection:AddButton({
    Title = "Teleport Now",
    Callback = goCave
})

AdminEventSection:AddButton({
    Title = "Return to Position",
    Callback = returnBack
})

-- Cleanup
player.CharacterRemoving:Connect(function()
    autoChristmasCave = false
    if checkThread then
        task.cancel(checkThread)
        checkThread = nil
    end
end)
 
-- Auto reconnect jika character mati
player.CharacterAdded:Connect(function()
    task.wait(2)
    if autoChristmasCave then
        checkThread = task.spawn(startCheckLoop)
    end
end)

-- =================================================================
-- REMOTE DEFINITIONS UNTUK AUTO TOTEM
-- =================================================================

local AutoSpawnTotem = Tabs.Automation:AddSection("Auto Totem")


local RPath = {"Packages", "_Index", "sleitnick_net@0.2.0", "net"}
local RepStorage = game:GetService("ReplicatedStorage")

-- Fungsi helper untuk mendapatkan remote
local function GetRemote(remotePath, name, timeout)
    local currentInstance = RepStorage
    for _, childName in ipairs(remotePath) do
        currentInstance = currentInstance:WaitForChild(childName, timeout or 0.5)
        if not currentInstance then return nil end
    end
    return currentInstance:FindFirstChild(name)
end
 
-- REMOTE YANG DIGUNAKAN OLEH AUTO TOTEM:
local RE_SpawnTotem = GetRemote(RPath, "RE/SpawnTotem") -- Untuk spawn totem
local RE_EquipToolFromHotbar = GetRemote(RPath, "RE/EquipToolFromHotbar") -- Equip rod setelah spawn
local RF_EquipOxygenTank = GetRemote(RPath, "RF/EquipOxygenTank") -- Anti-drown (ID 105)
local RF_UnequipOxygenTank = GetRemote(RPath, "RF/UnequipOxygenTank") -- Lepas oxygen tank
 
-- Remote tambahan yang mungkin digunakan:
local RE_EquipItem = GetRemote(RPath, "RE/EquipItem")
local RE_UnequipItem = GetRemote(RPath, "RE/UnequipItem")

-- =================================================================
-- TOTEM DATA & VARIABLES
-- =================================================================
local TOTEM_DATA = {
    ["Luck Totem"] = {Id = 1, Duration = 3601},     -- 1 jam 1 detik
    ["Mutation Totem"] = {Id = 2, Duration = 3601}, -- 1 jam 1 detik
    ["Shiny Totem"] = {Id = 3, Duration = 3601}     -- 1 jam 1 detik
}
 
local TOTEM_NAMES = {"Luck Totem", "Mutation Totem", "Shiny Totem"}
local selectedTotemName = "Luck Totem"
local currentTotemExpiry = 0
local AUTO_TOTEM_ACTIVE = false
local AUTO_TOTEM_THREAD = nil
 
local RunService = game:GetService("RunService")
 
-- =================================================================
-- 9 TOTEM FORMATION POSITIONS
-- =================================================================
local REF_CENTER = Vector3.new(93.932, 9.532, 2684.134)
local REF_SPOTS = {
    -- TENGAH (Y ~ 9.5)
    Vector3.new(45.0468979, 9.51625347, 2730.19067),   -- 1
    Vector3.new(145.644608, 9.51625347, 2721.90747),   -- 2
    Vector3.new(84.6406631, 10.2174253, 2636.05786),   -- 3
 
    -- ATAS (Y ~ 109.5)
    Vector3.new(45.0468979, 110.516253, 2730.19067),   -- 4
    Vector3.new(145.644608, 110.516253, 2721.90747),   -- 5
    Vector3.new(84.6406631, 111.217425, 2636.05786),   -- 6
 
    -- BAWAH (Y ~ -90.5)
    Vector3.new(45.0468979, -92.483747, 2730.19067),   -- 7
    Vector3.new(145.644608, -92.483747, 2721.90747),   -- 8
    Vector3.new(84.6406631, -93.782575, 2636.05786),   -- 9
}
 
local AUTO_9_TOTEM_ACTIVE = false
local AUTO_9_TOTEM_THREAD = nil
local stateConnection = nil -- Untuk loop pemaksa state
 
-- =================================================================
-- FLY ENGINE V3 (PHYSICS + STATE MANAGEMENT)
-- =================================================================
local function GetFlyPart()
    local player = game:GetService("Players").LocalPlayer
    local char = player.Character
    if not char then return nil end

    return char:FindFirstChild("HumanoidRootPart")
        or char:FindFirstChild("UpperTorso")
        or char:FindFirstChild("Torso")
end

local function SafeDisconnectState()
    if stateConnection then
        stateConnection:Disconnect()
        stateConnection = nil
    end
end

local function MaintainAntiFallState(enable)
    local char = game.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChild("Humanoid")
    if not hum then return end

    if enable then
        SafeDisconnectState()

        -- Disable physics-related states
        for _, state in ipairs({
            Enum.HumanoidStateType.Climbing,
            Enum.HumanoidStateType.FallingDown,
            Enum.HumanoidStateType.Flying,
            Enum.HumanoidStateType.Freefall,
            Enum.HumanoidStateType.GettingUp,
            Enum.HumanoidStateType.Jumping,
            Enum.HumanoidStateType.Landed,
            Enum.HumanoidStateType.Physics,
            Enum.HumanoidStateType.PlatformStanding,
            Enum.HumanoidStateType.Ragdoll,
            Enum.HumanoidStateType.Running,
            Enum.HumanoidStateType.RunningNoPhysics,
            Enum.HumanoidStateType.Seated,
            Enum.HumanoidStateType.StrafingNoPhysics,
            Enum.HumanoidStateType.Swimming
        }) do
            hum:SetStateEnabled(state, false)
        end

        -- Force swimming (air-stable)
        stateConnection = RunService.Heartbeat:Connect(function()
            if hum and AUTO_9_TOTEM_ACTIVE then
                hum:ChangeState(Enum.HumanoidStateType.Swimming)
                hum:SetStateEnabled(Enum.HumanoidStateType.Swimming, true)
            end
        end)
    else
        SafeDisconnectState()

        -- Restore default states
        for _, state in ipairs({
            Enum.HumanoidStateType.Climbing,
            Enum.HumanoidStateType.FallingDown,
            Enum.HumanoidStateType.Freefall,
            Enum.HumanoidStateType.Jumping,
            Enum.HumanoidStateType.Landed,
            Enum.HumanoidStateType.Physics,
            Enum.HumanoidStateType.Ragdoll,
            Enum.HumanoidStateType.Running,
            Enum.HumanoidStateType.Seated
        }) do
            hum:SetStateEnabled(state, true)
        end

        hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
    end
end

local function EnableV3Physics()
    local char = game.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChild("Humanoid")
    local mainPart = GetFlyPart()
    if not char or not hum or not mainPart then return end

    if char:FindFirstChild("Animate") then
        char.Animate.Disabled = true
    end

    hum.PlatformStand = true
    MaintainAntiFallState(true)

    local bg = mainPart:FindFirstChild("FlyGuiGyro")
        or Instance.new("BodyGyro", mainPart)
    bg.Name = "FlyGuiGyro"
    bg.P = 90000
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.CFrame = mainPart.CFrame

    local bv = mainPart:FindFirstChild("FlyGuiVelocity")
        or Instance.new("BodyVelocity", mainPart)
    bv.Name = "FlyGuiVelocity"
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bv.Velocity = Vector3.new(0, 0.1, 0)

    task.spawn(function()
        while AUTO_9_TOTEM_ACTIVE and char.Parent do
            for _, v in ipairs(char:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end
            task.wait(0.15)
        end
    end)
end

local function DisableV3Physics()
    local char = game.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChild("Humanoid")
    local mainPart = GetFlyPart()

    if mainPart then
        for _, name in ipairs({"FlyGuiGyro", "FlyGuiVelocity"}) do
            local obj = mainPart:FindFirstChild(name)
            if obj then obj:Destroy() end
        end

        mainPart.AssemblyLinearVelocity = Vector3.zero
        mainPart.AssemblyAngularVelocity = Vector3.zero
    end

    if hum then
        hum.PlatformStand = false
        hum:ChangeState(Enum.HumanoidStateType.GettingUp)
    end

    MaintainAntiFallState(false)

    if char and char:FindFirstChild("Animate") then
        char.Animate.Disabled = false
    end

    if char then
        for _, v in ipairs(char:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = true
            end
        end
    end
end

-- Fungsi gerak physics (FIXED & STABLE)
local function FlyPhysicsTo(targetPos)
    local mainPart = GetFlyPart()
    if not mainPart then return end

    local bv = mainPart:FindFirstChild("FlyGuiVelocity")
    local bg = mainPart:FindFirstChild("FlyGuiGyro")

    if not bv or not bg then
        EnableV3Physics()
        bv = mainPart:WaitForChild("FlyGuiVelocity", 1)
        bg = mainPart:WaitForChild("FlyGuiGyro", 1)
    end
    if not bv or not bg then return end

    local SPEED = 80
    local STOP_DISTANCE = 1.2
    local startTime = tick()

    while AUTO_9_TOTEM_ACTIVE do
        -- Failsafe timeout (anti stuck)
        if tick() - startTime > 10 then
            bv.Velocity = Vector3.new(0, 0.1, 0)
            break
        end

        local currentPos = mainPart.Position
        local diff = targetPos - currentPos
        local dist = diff.Magnitude

        -- Smooth facing (no spin)
        bg.CFrame = CFrame.new(currentPos, currentPos + diff)

        if dist <= STOP_DISTANCE then
            bv.Velocity = Vector3.new(0, 0.1, 0)
            break
        end

        -- Dynamic speed (lebih halus dekat target)
        local speedFactor = math.clamp(dist / 10, 0.25, 1)
        bv.Velocity = diff.Unit * SPEED * speedFactor

        RunService.Heartbeat:Wait()
    end
end


-- =================================================================
-- HELPER FUNCTIONS (FIXED)
-- =================================================================

local ReplionClient
local CachedDataReplion

local function GetPlayerDataReplion()
    -- Cache client
    if not ReplionClient then
        local pkg = RepStorage:WaitForChild("Packages", 5)
        if not pkg then return nil end

        local replionModule = pkg:FindFirstChild("Replion")
        if not replionModule then return nil end

        local ok, mod = pcall(require, replionModule)
        if not ok or not mod or not mod.Client then return nil end

        ReplionClient = mod.Client
    end

    -- Cache data replion
    if not CachedDataReplion then
        local ok, data = pcall(function()
            return ReplionClient:WaitReplion("Data", 5)
        end)
        if ok then
            CachedDataReplion = data
        end
    end

    return CachedDataReplion
end

local function GetTotemUUID(name)
    if not name or not TOTEM_DATA[name] then return nil end

    local r = GetPlayerDataReplion()
    if not r then return nil end

    local ok, inventory = pcall(function()
        return r:Get("Inventory")
    end)
    if not ok or not inventory or not inventory.Totems then return nil end

    for _, item in ipairs(inventory.Totems) do
        if tonumber(item.Id) == TOTEM_DATA[name].Id and (item.Count or 1) > 0 then
            return item.UUID
        end
    end

    return nil
end

-- =================================================================
-- LOGIC 9 TOTEM (FIXED & STABLE FOR SIRENX GUI)
-- =================================================================
local function Run9TotemLoop()
    if AUTO_9_TOTEM_THREAD then
        task.cancel(AUTO_9_TOTEM_THREAD)
    end

    AUTO_9_TOTEM_ACTIVE = true

    AUTO_9_TOTEM_THREAD = task.spawn(function()
        local success, err = pcall(function()

            -- Cek inventory awal
            local uuid = GetTotemUUID(selectedTotemName)
            if not uuid then
                sirenx("No Stock of " .. selectedTotemName .. "!")
                local t = AutoSpawnTotem:GetElementByTitle("Auto Spawn x9 Totem")
                if t then t:Set(false) end
                return
            end

            local player = game:GetService("Players").LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp = char:WaitForChild("HumanoidRootPart", 5)
            local hum = char:FindFirstChildOfClass("Humanoid")

            if not hrp then
                sirenx("Character not found!")
                return
            end

            -- SIMPAN POSISI & ORIENTASI
            local startPos = hrp.Position
            local startCFrame = hrp.CFrame
            local ox, oy, oz = startCFrame:ToEulerAnglesYXZ()

            sirenx("V3 Engine + Oxygen Protection activated!")

            -- Equip oxygen tank
            if RF_EquipOxygenTank then
                pcall(function()
                    RF_EquipOxygenTank:InvokeServer(105)
                end)
            end

            if hum then
                hum.Health = hum.MaxHealth
            end

            EnableV3Physics()

            -- LOOP 9 TITIK
            for i, refSpot in ipairs(REF_SPOTS) do
                if not AUTO_9_TOTEM_ACTIVE then break end

                local targetPos = startPos + (refSpot - REF_CENTER)
                TOTEM_STATUS_PARAGRAPH:SetDesc(("Flying to #%d..."):format(i))

                FlyPhysicsTo(targetPos)
                task.wait(0.6)

                uuid = GetTotemUUID(selectedTotemName)
                if not uuid then
                    sirenx("Totem out of stock!")
                    break
                end

                TOTEM_STATUS_PARAGRAPH:SetDesc(("Spawning #%d..."):format(i))
                pcall(function()
                    RE_SpawnTotem:FireServer(uuid)
                end)

                -- Re-equip rod
                task.spawn(function()
                    for _ = 1, 5 do
                        pcall(function()
                            RE_EquipToolFromHotbar:FireServer(1)
                        end)
                        task.wait(0.1)
                    end
                end)

                task.wait(1.5)
            end

            -- RETURN
            if AUTO_9_TOTEM_ACTIVE then
                TOTEM_STATUS_PARAGRAPH:SetDesc("Returning...")
                FlyPhysicsTo(startPos)
                task.wait(0.5)
                sirenx("Successfully spawned x9 " .. selectedTotemName .. "!")
            end
        end)

        -- ================= CLEANUP (ALWAYS RUN) =================
        if RF_UnequipOxygenTank then
            pcall(function()
                RF_UnequipOxygenTank:InvokeServer()
            end)
        end

        DisableV3Physics()

        local player = game:GetService("Players").LocalPlayer
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            task.wait(0.2)
            hrp.CFrame = CFrame.new(hrp.Position) * CFrame.fromEulerAnglesYXZ(ox or 0, oy or 0, oz or 0)
        end

        AUTO_9_TOTEM_ACTIVE = false

        local t = AutoSpawnTotem:GetElementByTitle("Auto Spawn x9 Totem")
        if t then t:Set(false) end

        TOTEM_STATUS_PARAGRAPH:SetTitle("Status: Inactive")
        TOTEM_STATUS_PARAGRAPH:SetDesc("Waiting...")

        if not success then
            warn("[Auto x9 Totem Error]:", err)
            sirenx("Auto x9 Totem error occurred.")
        end
    end)
end

-- =================================================================
-- LOGIC SINGLE TOTEM
-- =================================================================
local function RunAutoTotemLoop()
    if AUTO_TOTEM_THREAD then
        task.cancel(AUTO_TOTEM_THREAD)
    end

    AUTO_TOTEM_THREAD = task.spawn(function()
        while AUTO_TOTEM_ACTIVE do
            local now = os.time()
            local timeLeft = currentTotemExpiry - now

            if timeLeft > 0 then
                -- Countdown
                local m = math.floor(timeLeft / 60)
                local s = timeLeft % 60

                TOTEM_STATUS_PARAGRAPH:SetTitle(
                    "Status: " .. selectedTotemName .. " Active"
                )
                TOTEM_STATUS_PARAGRAPH:SetDesc(
                    string.format("Next Spawn: %02d:%02d", m, s)
                )

            else
                -- Spawn single totem
                TOTEM_STATUS_PARAGRAPH:SetDesc("Spawning Single...")
                local uuid = GetTotemUUID(selectedTotemName)

                if not AUTO_TOTEM_ACTIVE then break end

                if uuid then
                    pcall(function()
                        RE_SpawnTotem:FireServer(uuid)
                    end)

                    -- SET EXPIRY SETELAH SPAWN
                    currentTotemExpiry = now + TOTEM_DATA[selectedTotemName].Duration

                    -- Re-equip rod
                    task.spawn(function()
                        for i = 1, 3 do
                            if not AUTO_TOTEM_ACTIVE then break end
                            task.wait(0.2)
                            pcall(function()
                                RE_EquipToolFromHotbar:FireServer(1)
                            end)
                        end
                    end)
                else
                    -- HABIS â†’ STOP LOOP
                    sirenx("Not have totem in inventory!")

                    AUTO_TOTEM_ACTIVE = false
                    local t = AutoSpawnTotem:GetElementByTitle("Enable Auto Totem (Single)")
                    if t then t:Set(false) end
                    break
                end
            end

            task.wait(1)
        end

        -- CLEAN UI
        TOTEM_STATUS_PARAGRAPH:SetTitle("Status: Inactive")
        TOTEM_STATUS_PARAGRAPH:SetDesc("Inactive")
    end)
end


-- ================================================================
-- DROPDOWN : SELECT TOTEM TYPE
-- ================================================================

AutoSpawnTotem:AddDropdown({
    Title = "Select Totem Type",
    Content = "Choose which totem will be used",
    Options = {
        "Luck Totem",
        "Mutation Totem",
        "Shiny Totem"
    },
    Default = "Luck Totem",
    Callback = function(value)
        selectedTotemName = value
        currentTotemExpiry = 0

        TOTEM_STATUS_PARAGRAPH:SetTitle("Status: " .. value)
        TOTEM_STATUS_PARAGRAPH:SetDesc("Selected")
        sirenx("Selected Totem: " .. value)
    end
})

AutoSpawnTotem:AddToggle({
    Title = "Enable Auto Totem (Single)",
    Default = false,
    Callback = function(state)
        AUTO_TOTEM_ACTIVE = state
        if state then
            RunAutoTotemLoop()
            sirenx("Auto Totem (Single) enabled.")
        else
            if AUTO_TOTEM_THREAD then
                task.cancel(AUTO_TOTEM_THREAD)
                AUTO_TOTEM_THREAD = nil
            end
            TOTEM_STATUS_PARAGRAPH:SetTitle("Status: Inactive")
            TOTEM_STATUS_PARAGRAPH:SetDesc("Inactive")
            sirenx("Auto Totem stopped.")
        end
    end
})

AutoSpawnTotem:AddToggle({
    Title = "Auto Spawn x9 Totem",
    Default = false,
    Callback = function(state)
        AUTO_9_TOTEM_ACTIVE = state
        if state then
            Run9TotemLoop()
            sirenx("Auto x9 Totem started.")
        else
            if AUTO_9_TOTEM_THREAD then
                task.cancel(AUTO_9_TOTEM_THREAD)
                AUTO_9_TOTEM_THREAD = nil
            end
            DisableV3Physics()
            TOTEM_STATUS_PARAGRAPH:SetTitle("Status: Inactive")
            TOTEM_STATUS_PARAGRAPH:SetDesc("Stopped")
            sirenx("Auto x9 Totem stopped.")
        end
    end
})

AutoSpawnTotem:AddButton({
    Title = "Spawn Totem Now",
    Callback = function()
        local uuid = GetTotemUUID(selectedTotemName)
        if uuid then
            pcall(function()
                RE_SpawnTotem:FireServer(uuid)
            end)
            sirenx("Totem spawned: " .. selectedTotemName)
        else
            sirenx("Not have totem in inventory!")
        end
    end
})

local Sirenx = loadstring(game:HttpGet("https://raw.githubusercontent.com/rendy45kz/vir/refs/heads/main/aegishub.lua"))()

local Window = Sirenx:Window({
  Title   = "AegisHUB |",
  Footer  = "Fish It",
  Image   = "85286478652862",
  Color   = Color3.fromRGB(0, 150, 255),
  Theme   = 133682498103356,
  Version = 1,
})

local svc = {
  Players     = game:GetService("Players"),
  RunService  = game:GetService("RunService"),
  HttpService = game:GetService("HttpService"),
  RS          = game:GetService("ReplicatedStorage"),
  VU          = game:GetService("VirtualUser"),
  VIM         = game:GetService("VirtualInputManager"),
  PG          = game:GetService("Players").LocalPlayer.PlayerGui,
  Camera      = workspace.CurrentCamera,
  GuiService  = game:GetService("GuiService"),
  CoreGui     = game:GetService("CoreGui"),
  Stats       = game:GetService("Stats"),
  TpService   = game:GetService("TeleportService"),
  Starter     = game:GetService("StarterPlayer"),
  UIS         = game:GetService("UserInputService"),
}

_G.httpRequest =
  (syn and syn.request)
  or (http and http.request)
  or http_request
  or (fluxus and fluxus.request)
  or request
if not _G.httpRequest then
  return
end

local player = svc.Players.LocalPlayer
local function getHRP()
  local char = player.Character or player.CharacterAdded:Wait()
  return char:WaitForChild("HumanoidRootPart")
end
local function getHumanoid()
  local char = player.Character or player.CharacterAdded:Wait()
  return char:WaitForChild("Humanoid")
end

local BaseFolder           = "AegisHub"
local PositionFile         = BaseFolder .. "/Position.json"

local gui = {
  Merchant        = svc.PG.Merchant,
  MerchantRoot    = svc.PG.Merchant.Main.Background,
  ItemsFrame      = svc.PG.Merchant.Main.Background.Items.ScrollingFrame,
  RefreshMerchant = svc.PG.Merchant.Main.Background.RefreshLabel,
}

local mods = {
  Net                     = svc.RS.Packages._Index["sleitnick_net@0.2.0"].net,
  Replion                 = require(svc.RS.Packages.Replion),
  FishingController       = require(svc.RS.Controllers.FishingController),
  NotificationController  = require(svc.RS.Controllers.NotificationController),
  AnimationController     = require(svc.RS.Controllers.AnimationController),
  CutsceneController      = require(svc.RS.Controllers.CutsceneController),
  TradingController       = require(svc.RS.Controllers.ItemTradingController),
  ItemUtility             = require(svc.RS.Shared.ItemUtility),
  VendorUtility           = require(svc.RS.Shared.VendorUtility),
  CutsceneUtility         = require(svc.RS.Shared.CutsceneUtility),
  PlayerStatsUtility      = require(svc.RS.Shared.PlayerStatsUtility),
  Effects                 = require(svc.RS.Shared.Effects),
  NotifierFish            = require(svc.RS.Controllers.TextNotificationController),
  InputControl            = require(svc.RS.Modules.InputControl),
  VFX                     = require(svc.RS.Controllers.VFXController)
}

local api = {
  Events = {
    RECutscene                    = mods.Net["RE/ReplicateCutscene"],
    REStop                        = mods.Net["RE/StopCutscene"],
    REFav                         = mods.Net["RE/FavoriteItem"],
    REFavChg                      = mods.Net["RE/FavoriteStateChanged"],
    REFishDone                    = mods.Net["RE/FishingCompleted"],
    REFishGot                     = mods.Net["RE/FishCaught"],
    RENotify                      = mods.Net["RE/TextNotification"],
    REEquip                       = mods.Net["RE/EquipToolFromHotbar"],
    REEquipItem                   = mods.Net["RE/EquipItem"],
    REAltar                       = mods.Net["RE/ActivateEnchantingAltar"],
    REAltar2                      = mods.Net["RE/ActivateSecondEnchantingAltar"],
    UpdateOxygen                  = mods.Net["URE/UpdateOxygen"],
    REPlayFishEffect              = mods.Net["RE/PlayFishingEffect"],
    RETextEffect                  = mods.Net["RE/ReplicateTextEffect"],
    REEvReward                    = mods.Net["RE/ClaimEventReward"],
    Totem                         = mods.Net["RE/SpawnTotem"],
    REObtainedNewFishNotification = mods.Net["RE/ObtainedNewFishNotification"],
    FishingMinigameChanged        = mods.Net["RE/FishingMinigameChanged"],
    FishingStopped                = mods.Net["RE/FishingStopped"],
  },

  Functions = {
    Trade       = mods.Net["RF/InitiateTrade"],
    BuyRod      = mods.Net["RF/PurchaseFishingRod"],
    BuyBait     = mods.Net["RF/PurchaseBait"],
    BuyWeather  = mods.Net["RF/PurchaseWeatherEvent"],
    ChargeRod   = mods.Net["RF/ChargeFishingRod"],
    StartMini   = mods.Net["RF/RequestFishingMinigameStarted"],
    UpdateRadar = mods.Net["RF/UpdateFishingRadar"],
    Cancel      = mods.Net["RF/CancelFishingInputs"],
    Dialogue    = mods.Net["RF/SpecialDialogueEvent"],
    SellItem    = mods.Net["RF/SellItem"],
    SellAllItem = mods.Net["RF/SellAllItems"],
    AutoEnabled = mods.Net["RF/UpdateAutoFishingState"]
  }
}

local st                   = {
  player           = player,
  walk             = false,
  walkSpeed        = 16,
  infiniteJump     = false,
  hideIdentity     = false,
  hideNames        = "AegisHUB",
  hideLevels       = "---------",
  char             = player.Character or player.CharacterAdded:Wait(),
  menuRings        = workspace:WaitForChild("!!! MENU RINGS"),
  zones            = workspace:WaitForChild("Zones"),
  vim              = svc.VIM,
  cam              = svc.Camera,
  fishingLegit     = false,
  minigameDelay    = 0.1,
  autoFishing      = false,
  completeDelay    = 0.7,
  instantFishing   = false,

  teleport = {
    island = nil,
    event  = nil,
    player = nil,
  },
  shop = {
    weather       = {},
    autoWeather   = false,
  },
  sell = {
    enabled = false,
    caughtTarget = 100,
    sellThread = nil,
},
  market = {
    autoSellThreshold = "Legendary",
    sellAtAmount      = 500,
    autoSell          = false,
    enchSellAt        = 100,
    enchSell          = false,
  },
  favorite = {
    auto             = false,
    names            = {},
    rarities         = {},
    mutations        = {},
  },
  hide = {
    notifications   = false,
    cutscenes       = false,
    animations      = false,
    vfx             = false,
  },
  quest = {
    autoDeepSea      = false,
    autoElement      = false,
    autoQuestFlow    = false,
    triggerRuin      = false,
    autoClassicEvent = false,
  },

  perfection = {
    activated = false,   -- toggle manual
    enabled = false,     -- state internal
    autoByInstant = false,
}
}
local ConnectionWalkSpeed = nil
local antiAfkConnection = nil
local oldRequestCharge = nil
local autoSellCount = 0
local autoSellCooldown = false

local TeleportConfig = {
    PlaceId = game.PlaceId,
    RejoinDelay = 5,
    HopDelay = 5,
    AutoRejoin = false,
    AutoHop = false
}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

-- STATE
local isWalkOnWater = false
local waterPlatform = nil
local walkOnWaterConnection = nil

-- CONFIG
local PLATFORM_SIZE = Vector3.new(18, 1, 18)
local WATER_OFFSET  = 3.2
local RAY_DISTANCE  = 30

--==================================================
-- ANTI DROWN (OXYGEN BYPASS - SAFE)
--==================================================

local AntiDrown = {
    Enabled = false,
    Hooked = false
}

--==================================================
-- METATABLE HOOK (LOAD ONCE)
--==================================================
local rawmt = getrawmetatable(game)
if rawmt and not AntiDrown.Hooked then
    setreadonly(rawmt, false)

    local oldNamecall = rawmt.__namecall

    rawmt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()

        -- BLOCK OXYGEN UPDATE
        if AntiDrown.Enabled
            and method == "FireServer"
            and tostring(self) == "URE/UpdateOxygen"
        then
            return nil
        end

        return oldNamecall(self, ...)
    end)

    setreadonly(rawmt, true)
    AntiDrown.Hooked = true
end

--==================================================
-- CREATE PLATFORM (ONCE)
--==================================================
local function CreateWaterPlatform()
    local p = Instance.new("Part")
    p.Name = "WaterPlatform"
    p.Anchored = true
    p.CanCollide = true
    p.Transparency = 1
    p.Size = PLATFORM_SIZE
    p.CastShadow = false
    p.Parent = workspace
    return p
end

--==================================================
-- WALK ON WATER (FIXED & STABLE)
--==================================================

local function EnableWalkOnWater()
    if isWalkOnWater then return end
    isWalkOnWater = true

    if not waterPlatform then
        waterPlatform = CreateWaterPlatform()
    end

    if walkOnWaterConnection then
        walkOnWaterConnection:Disconnect()
    end

    walkOnWaterConnection = RunService.Stepped:Connect(function()
        if not isWalkOnWater then return end

        local char = LocalPlayer.Character
        if not char then return end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then return end

        -- RAYCAST ONLY TERRAIN (WATER)
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Include
        params.FilterDescendantsInstances = { workspace.Terrain }
        params.IgnoreWater = false

        local origin = hrp.Position + Vector3.new(0, 6, 0)
        local direction = Vector3.new(0, -120, 0)

        local result = workspace:Raycast(origin, direction, params)

        if result and result.Material == Enum.Material.Water then
            local waterY = result.Position.Y

            -- PLATFORM IKUT PLAYER (SEDIKIT DI BAWAH AIR)
            waterPlatform.Position = Vector3.new(
                hrp.Position.X,
                waterY - 0.3,
                hrp.Position.Z
            )

            -- JAGA PLAYER TIDAK TENGGELAM SAAT JALAN
            if hrp.Position.Y < waterY + 2 then
                if not UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    hrp.AssemblyLinearVelocity = Vector3.new(
                        hrp.AssemblyLinearVelocity.X,
                        0,
                        hrp.AssemblyLinearVelocity.Z
                    )

                    hrp.CFrame = CFrame.new(
                        hrp.Position.X,
                        waterY + 3,
                        hrp.Position.Z
                    )
                end
            end
        else
            -- JANGAN HILANGKAN PLATFORM, IKUTI PLAYER
            waterPlatform.Position = Vector3.new(
                hrp.Position.X,
                hrp.Position.Y - 6,
                hrp.Position.Z
            )
        end
    end)
end


--==================================================
-- DISABLE WALK ON WATER
--==================================================
local function DisableWalkOnWater()
    if not isWalkOnWater then return end
    isWalkOnWater = false

    if walkOnWaterConnection then
        walkOnWaterConnection:Disconnect()
        walkOnWaterConnection = nil
    end

    if waterPlatform then
        waterPlatform:Destroy()
        waterPlatform = nil
    end
end


-- TRACK UUID YANG SUDAH DIHITUNG
local countedFishUUID = {}

local function EnablePerfection()
    if st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(true)
    end)

    pcall(function()
        if not oldRequestCharge then
            oldRequestCharge = mods.FishingController.RequestChargeFishingRod
        end
        mods.FishingController.RequestChargeFishingRod = function()
            return nil
        end
    end)

    st.perfection.enabled = true
end

local function DisablePerfection()
    if not st.perfection.enabled then return end

    pcall(function()
        api.Functions.ChargeRod:InvokeServer(false)
    end)

    pcall(function()
        if oldRequestCharge then
            mods.FishingController.RequestChargeFishingRod = oldRequestCharge
            oldRequestCharge = nil
        end
    end)

    st.perfection.enabled = false
end


st.player.CharacterAdded:Connect(function(char)
  st.char = char
end)

local repl = {
  Data = mods.Replion.Client:WaitReplion("Data"),
  Items = svc.RS:WaitForChild("Items"),
  Variants = svc.RS:WaitForChild("Variants"),
  PlayerStat = require(svc.RS.Packages._Index:FindFirstChild("ytrev_replion@2.0.0-rc.3").replion)
}

player.Idled:Connect(function()
	svc.VU:CaptureController()
	svc.VU:ClickButton2(Vector2.zero)
	st.vim:SendKeyEvent(true, Enum.KeyCode.RightMeta, false, game)
	st.vim:SendKeyEvent(false, Enum.KeyCode.RightMeta, false, game)
end)

local Tabs = {
  Info = Window:AddTab({ Name = "Info", Icon = "player" }),
  Player = Window:AddTab({ Name = "Player", Icon = "user" }),
  Fishing = Window:AddTab({ Name = "Fishing", Icon = "fish" }),
  Shop = Window:AddTab({ Name = "Shop", Icon = "shop" }),
  Automation = Window:AddTab({ Name = "Automation", Icon = "next" }),
  Teleport = Window:AddTab({ Name = "Teleport", Icon = "gps" }),
  Misc = Window:AddTab({ Name = "Misc", Icon = "settings" }),
}

InfoSection = Tabs.Info:AddSection("Information", true)

InfoSection:AddParagraph({
  Title = "Join Whatsapp Server",
  Content = "Join Us!",
  Icon = "whatsapp",
  ButtonText = "Copy Whatsapp Link",
  ButtonCallback = function()
    local link = "https://chat.whatsapp.com/DU81SA1xaoiA5nOvxAr5OR"
    if setclipboard then
      setclipboard(link)
      sirenx("Successfully Copied!")
    end
  end
})

ServerSection = Tabs.Info:AddSection("Server")

local CurrentServer = ServerSection:AddParagraph({
  Title = "Current Server",
  Content = [[
Ping: 0 ms | FPS: 0/s | Players: 0/0
  ]],
  Icon = "stat",
})

task.spawn(function()
  while task.wait(1) do
    CurrentServer:SetContent(
      string.format([[
Ping: %d ms | FPS: %d/s | Players: %d/%d
      ]],
        math.floor(svc.Stats.PerformanceStats.Ping:GetValue() + 0.5),
        math.floor(1 / svc.RunService.RenderStepped:Wait() + 0.5),
        #svc.Players:GetPlayers(),
        svc.Players.MaxPlayers
      )
    )
  end
end)

ServerSection:AddButton({
  Title = "Rejoin Server",
  Content = "Rejoins the current server",
  Callback = function()
    sirenx("Rejoining Server...")
    svc.TpService:Teleport(game.PlaceId, player)
  end
})

Plyrs = Tabs.Player:AddSection("Player")

Plyrs:AddToggle({
  Title = "Enable",
  Content = "Enable Walk Speed Changer",
  Default = false,
  Callback = function(state)
    st.walk = state

    if ConnectionWalkSpeed then
      ConnectionWalkSpeed:Disconnect()
      ConnectionWalkSpeed = nil
    end

    if state then
      local hum = getHumanoid()
      hum.WalkSpeed = st.walkSpeed
      ConnectionWalkSpeed = hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if st.walk and hum.WalkSpeed ~= st.walkSpeed then
          hum.WalkSpeed = st.walkSpeed
        end
      end)
    else
      getHumanoid().WalkSpeed = svc.Starter.CharacterWalkSpeed
    end
  end
})

Plyrs:AddSlider({
  Title = "Walk Speed",
  Content = "Change your walk speed",
  Min = 16,
  Max = 500,
  Increment = 1,
  Default = st.walkSpeed,
  Callback = function(value)
    st.walkSpeed = value
    if st.walk then
      getHumanoid().WalkSpeed = value
    end
  end
})

Plyrs:AddToggle({
  Title = "Walk on Water",
  Content = "Allows you to walk on water",
  Default = false,
  Callback = function(state)
    if state then
      EnableWalkOnWater()
    else
      DisableWalkOnWater()
    end
  end
})

Plyrs:AddToggle({
    Title = "Anti Drown (Bypass)",
    Content = "Block oxygen update (no drowning)",
    Default = false,
    Callback = function(state)
        AntiDrown.Enabled = state
    end
})

Plyrs:AddToggle({
  Title = "Infinite Jump",
  Content = "Allows you to jump infinitely",
  Default = false,
  Callback = function(state)
    st.infiniteJump = state
    if state then
      svc.UIS.JumpRequest:Connect(function()
        if st.infiniteJump then
          local hum = getHumanoid()
          hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
      end)
    end
  end
}, "InfiniteJump")

local Connections = {}
local OriginalText = {}
local DescendantAddedConnection = nil

local function HandleUsernameChange(Object)
	if not st.hideIdentity or not (Object:IsA("TextLabel") or Object:IsA("TextBox") or Object:IsA("TextButton")) then
		return
	end

	if not Connections[Object] then
		Connections[Object] = Object:GetPropertyChangedSignal("Text"):Connect(function()
			HandleUsernameChange(Object)
		end)
	end

	local text = Object.Text
	if text:find(st.player.Name) or text:find(st.player.DisplayName) then
		OriginalText[Object] = text
		Object.Text = text:gsub(st.player.Name, st.hideNames):gsub(st.player.DisplayName, st.hideNames)
	end
end

Plyrs:AddInput({
  Title = "Set Name",
  Content = "Sets the name to replace your username with",
  Default = st.hideNames,
  Placeholder = st.hideNames,
  Callback = function(value)
    st.hideNames = value
  end
})

Plyrs:AddInput({
  Title = "Set Level Text",
  Content = "Sets the text to replace your level with",
  Default = st.hideLevels,
  Placeholder = st.hideLevels,
  Callback = function(value)
    st.hideLevels = value
  end
})

Plyrs:AddToggle({
	Title = "Hide Identity",
	Content = "Hides your player identity locally",
	Default = false,
	Callback = function(state)
		st.hideIdentity = state

		if state then 
			if DescendantAddedConnection then
				DescendantAddedConnection:Disconnect()
			end

			for i,v in pairs(game:GetDescendants()) do
				pcall(function()
					HandleUsernameChange(v)
				end)
			end

			pcall(function()
				local label = st.char.HumanoidRootPart.Overhead.LevelContainer.Label
				if label and not OriginalText[label] then
					OriginalText[label] = label.Text
				end
				label.Text = st.hideLevels
			end)

			DescendantAddedConnection = game.DescendantAdded:Connect(function(v)
				pcall(function()
					HandleUsernameChange(v)
				end)
			end)
		else
			if DescendantAddedConnection then
				DescendantAddedConnection:Disconnect()
				DescendantAddedConnection = nil
			end

			for Object, Connection in pairs(Connections) do
				if Connection then
					Connection:Disconnect()
				end
			end
			Connections = {}

			if OriginalText then
				for Object, Text in pairs(OriginalText) do
					if Object and Object.Parent then
						pcall(function()
							Object.Text = Text
						end)
					end
				end
				OriginalText = {}
			end
		end
	end
})

local Camera = Tabs.Player:AddSection("Camera")

Camera:AddToggle({
  Title = "Max Zoom",
  Content = "Allows you to zoom out the furthest",
  Default = false,
  Callback = function(state)
    ConnectionZoom = ConnectionZoom or nil

    if ConnectionZoom then
      ConnectionZoom:Disconnect()
      ConnectionZoom = nil
    end

    if state then
      st.player.CameraMaxZoomDistance = 50000
      ConnectionZoom = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
        if st.player.CameraMaxZoomDistance ~= 50000 then
          st.player.CameraMaxZoomDistance = 50000
        end
      end)
    else
      st.player.CameraMaxZoomDistance = svc.Starter.CameraMaxZoomDistance
    end
  end
})

local AutoFishing = Tabs.Fishing:AddSection("Instant Fishing")

api.Events.RETextEffect.OnClientEvent:Connect(function(data)
  if not (data and data.TextData and data.TextData.EffectType == "Exclaim") then return end
  if not (st.char and data.Container == st.char:FindFirstChild("Head")) then return end

  if st.autoFishing then
    task.delay(st.completeDelay, function()
      pcall(api.Events.REFishDone.FireServer, api.Events.REFishDone)
    end)
  end
end)

AutoFishing:AddToggle({
  Title = "Instant Fishing",
  Content = "Automatically fishes for you",
  Default = false,
  Callback = function(state)
    st.autoFishing = state

    task.spawn(function()
      api.Functions.AutoEnabled:InvokeServer(state)
      while st.autoFishing do
        api.Functions.ChargeRod:InvokeServer()
        api.Functions.StartMini:InvokeServer(-1, 0.999, workspace:GetServerTimeNow())
        task.wait(0.5)
      end
    end)
  end
})

AutoFishing:AddInput({
  Title = "Complete Delay",
  Content = "Delay for complete fishing",
  Default = tostring(st.completeDelay),
  Callback = function(value)
    local num = tonumber(value)
    if not num or num < 0 or num > 5 then
      task.spawn(function()
        task.wait()
        CD:Set(tostring(st.completeDelay))
      end)
    end
    st.completeDelay = num
  end
})

--//======================================================
--// BLATANT FISHING (IMPROVED SPEED - SAME LOGIC)
--//======================================================

local Fish2 = Tabs.Fishing:AddSection("Blatant Fishing")

_G.FBlatant = _G.FBlatant or false
_G.Reel = _G.Reel or 1.9
_G.FishingDelay = _G.FishingDelay or 0.9

-- FASTEST FUNCTION (IMPROVED, LOGIC SAMA)
function Fastest()
    task.spawn(function()
        local now = workspace:GetServerTimeNow()

        pcall(function()
            api.Functions.Cancel:InvokeServer()
        end)

        pcall(function()
            api.Functions.ChargeRod:InvokeServer(now)
        end)

        pcall(function()
            api.Functions.StartMini:InvokeServer(-1.233184814453125, 0.994503488563327303, now)
        end)

        task.wait(_G.FishingDelay)

        pcall(function()
            api.Events.REFishDone:FireServer()
        end)
    end)
end

-- TOGGLE BLATANT
Fish2:AddToggle({
    Title = "Blatant Fishing",
    Default = _G.FBlatant,
    Callback = function(s)
        _G.FBlatant = s
        api.Functions.AutoEnabled:InvokeServer(s)

        if s then
            -- AUTO ENABLE PERFECTION
            st.perfection.autoByInstant = true
            EnablePerfection()

            st.player:SetAttribute("Loading", nil)

            task.spawn(function()
                while _G.FBlatant do
                    Fastest()
                    task.wait(_G.Reel)
                end
            end)
        else
            st.player:SetAttribute("Loading", false)

            -- AUTO DISABLE PERFECTION (AMAN)
            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})

-- INPUT REEL DELAY
Fish2:AddInput({
    Title = "Delay Reel",
    Value = tostring(_G.Reel),
    Default = "1.9",
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            _G.Reel = n
            SaveConfig()
        end
    end
})

-- INPUT FISHING DELAY
Fish2:AddInput({
    Title = "Delay Fishing",
    Value = tostring(_G.FishingDelay),
    Default = "1.1",
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            _G.FishingDelay = n
            SaveConfig()
        end
    end
})

--//======================================================
--// ULTRA BLATANT FISHING (IMPROVED & STABLE)
--//======================================================

local UltraBlatant = {
    Active = false,
    CompleteDelay = 0.7,
    CancelDelay = 0.3,
    Thread = nil
}

-- SAFE CALL (ANDROID FRIENDLY)
local function SafeCall(fn)
    task.spawn(function()
        pcall(fn)
    end)
end

-- ULTRA CAST (FASTER, SAME FLOW)
local function UltraCast()
    local t = workspace:GetServerTimeNow()

    SafeCall(function()
        api.Functions.ChargeRod:InvokeServer(t)
    end)

    task.wait() -- 1 frame yield (lebih stabil dari 0.01)

    SafeCall(function()
        api.Functions.StartMini:InvokeServer(-1.233184814453125, 0.994503488563327303, t)
    end)
end

-- ULTRA LOOP
local function UltraLoop()
    while UltraBlatant.Active do
        UltraCast()

        task.wait(UltraBlatant.CompleteDelay)

        if UltraBlatant.Active then
            SafeCall(function()
                api.Events.REFishDone:FireServer()
            end)
        end

        task.wait(UltraBlatant.CancelDelay)

        if UltraBlatant.Active then
            SafeCall(function()
                api.Functions.Cancel:InvokeServer()
            end)
        end
    end
end

--======================================================
-- GUI ULTRA SECTION
--======================================================

local UltraSection = Tabs.Fishing:AddSection("Blatant BETA")

UltraSection:AddToggle({
    Title = "Ultra Blatant Fishing",
    Content = "Extremely fast & aggressive fishing",
    Default = false,
    Callback = function(state)
        UltraBlatant.Active = state

        if state then
            -- AUTO ENABLE PERFECTION
            st.perfection.autoByInstant = true
            EnablePerfection()

            -- EQUIP ROD
            SafeCall(function()
                api.Events.REEquip:FireServer(1)
            end)

            task.wait(0.15)

            UltraBlatant.Thread = task.spawn(UltraLoop)
        else
            UltraBlatant.Active = false

            SafeCall(function()
                api.Functions.Cancel:InvokeServer()
            end)

            st.perfection.autoByInstant = false
            if not st.perfection.activated then
                DisablePerfection()
            end
        end
    end
})

UltraSection:AddInput({
    Title = "Complete Delay",
    Content = "Delay before fish completed",
    Default = tostring(UltraBlatant.CompleteDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then
            UltraBlatant.CompleteDelay = n
        end
    end
})

UltraSection:AddInput({
    Title = "Cancel Delay",
    Content = "Delay before cancel input",
    Default = tostring(UltraBlatant.CancelDelay),
    Callback = function(v)
        local n = tonumber(v)
        if n and n >= 0 then
            UltraBlatant.CancelDelay = n
        end
    end
})

local FishFeature = Tabs.Fishing:AddSection("Fishing Features")

FishFeature:AddToggle({
    Title = "Perfection Support",
    Content = "Enable perfection & block rod charging",
    Default = false,
    Callback = function(state)
        st.perfection.activated = state

        if state then
            EnablePerfection()
        else
            -- jangan matikan jika Instant Fishing aktif
            if not st.perfection.autoByInstant then
                DisablePerfection()
            end
        end
    end
})

FishFeature:AddButton({
  Title = "Recovery Fishing",
  Callback = function()
    task.spawn(function()
      pcall(function()
        api.Functions.Cancel:InvokeServer()
      end)
      local lp = game:GetService("Players").LocalPlayer
      lp:SetAttribute("Loading", nil)
      task.wait(0.05)
      lp:SetAttribute("Loading", false)
    end)
  end
})

local SellGroup = Tabs.Fishing:AddSection("Auto Selling")

----------------------------------------------------------------
-- EVENT LISTENER
----------------------------------------------------------------
api.Events.REObtainedNewFishNotification.OnClientEvent:Connect(function(itemId, _, info)
    if not st.sell.enabled then return end
    if autoSellCooldown then return end
    if not info or not info.InventoryItem then return end

    local uuid = info.InventoryItem.UUID
    if not uuid then return end

    if countedFishUUID[uuid] then return end
    countedFishUUID[uuid] = true

    -- âœ… HITUNG 1 IKAN VALID
    autoSellCount += 1

    local target = tonumber(st.sell.caughtTarget) or 0
    if target <= 0 then return end

    if autoSellCount >= target then
        autoSellCooldown = true

        task.spawn(function()
            pcall(function()
                api.Functions.SellAllItem:InvokeServer()
            end)
            -- RESET SETELAH SELL
            autoSellCount = 0
            table.clear(countedFishUUID)

            task.wait(1.5)
            autoSellCooldown = false
        end)
    end
end)


----------------------------------------------------------------
-- GUI INPUT
----------------------------------------------------------------
SellGroup:AddInput({
    Title = "Sell When Caught â‰¥",
    Content = "Auto sell after catching X fish",
    Default = tostring(st.sell.caughtTarget),
    Numeric = true,
    Callback = function(v)
        local n = tonumber(v)
        st.sell.caughtTarget = n or 0
    end
})

----------------------------------------------------------------
-- TOGGLE
----------------------------------------------------------------
SellGroup:AddToggle({
    Title = "Auto Sell by Fish Caught",
    Content = "Sell after catching X fish",
    Default = false,
    Callback = function(state)
        st.sell.enabled = state

        autoSellCount = 0
        table.clear(countedFishUUID)
        autoSellCooldown = false
    end
})


----------------------------------------------------------------
-- MANUAL BUTTON
----------------------------------------------------------------
SellGroup:AddButton({
    Title = "Sell All Now",
    Content = "Immediately sell all fish in inventory",
    Callback = function()
        pcall(function()
            api.Functions.SellAllItem:InvokeServer()
        end)
    end
})


local Favorites = Tabs.Fishing:AddSection("Favorites")

----------------------------------------------------------------
-- CHECK FAVORITE
----------------------------------------------------------------
local function IsFavorited(UUID)
    local items = repl.Data.Data.Inventory.Items
    if not items then return false end

    for _, Item in pairs(items) do
        if Item.UUID == UUID then
            return Item.Favorited == true
        end
    end
    return false
end

----------------------------------------------------------------
-- AUTO FAVORITE CORE (RARITY FIX)
----------------------------------------------------------------
local function AutoFavorite(names, rarities, mutations)
    local items = repl.Data.Data.Inventory.Items
    if not items or #items == 0 then return end

    local rarityMap   = {}
    local nameMap     = {}
    local mutationMap = {}

    -- BUILD MAP (STRING BASED)
    if rarities then
        for _, r in ipairs(rarities) do
            rarityMap[tostring(r)] = true
        end
    end

    if names then
        for _, n in ipairs(names) do
            nameMap[tostring(n)] = true
        end
    end

    if mutations then
        for _, m in ipairs(mutations) do
            mutationMap[tostring(m)] = true
        end
    end

    local toFavorite = {}

    for _, Item in pairs(items) do
        if not Item.Favorited then
            local FishData = mods.ItemUtility:GetItemData(Item.Id)
            if FishData and FishData.Data then
                local data = FishData.Data
                local rarity = tostring(data.Tier)
                local name   = tostring(data.Name)
                local mutId  = Item.Metadata and Item.Metadata.VariantId

                if
                    (rarityMap[rarity]) or
                    (nameMap[name]) or
                    (mutId and mutationMap[mutId])
                then
                    table.insert(toFavorite, Item.UUID)
                end
            end
        end
    end

    for i, uuid in ipairs(toFavorite) do
        task.spawn(function()
            task.wait(i * 0.05)
            api.Events.REFav:FireServer(uuid)
        end)
    end
end

----------------------------------------------------------------
-- UNFAVORITE ALL
----------------------------------------------------------------
local function UnAutoFavoriteAll()
    local items = repl.Data.Data.Inventory.Items
    if not items then return end

    for _, Item in pairs(items) do
        if Item.Favorited then
            pcall(function()
                api.Events.REFav:FireServer(Item.UUID)
            end)
        end
    end
end

----------------------------------------------------------------
-- DROPDOWNS
----------------------------------------------------------------
Favorites:AddDropdown({
    Title = "Auto Favorite by Rarity",
    Content = "Favorite by Fish Rarity",
    Multi = true,
    Options = {"Common","Uncommon","Rare","Epic","Legendary","Mythic","Secret"},
    Default = st.favorite.rarities,
    Callback = function(v)
        st.favorite.rarities = v
    end
})

-- CACHE FISH NAMES
local cachedFishNames
local function GetFishNames()
    if cachedFishNames then return cachedFishNames end

    local list = {}
    for _, Item in pairs(repl.Items:GetChildren()) do
        local FishData = mods.ItemUtility:GetItemData(Item.Name)
        if FishData and FishData.Data and FishData.Data.Type == "Fish" then
            table.insert(list, FishData.Data.Name)
        end
    end
    cachedFishNames = list
    return list
end

Favorites:AddDropdown({
    Title = "Auto Favorite by Name",
    Multi = true,
    Options = GetFishNames(),
    Default = st.favorite.names,
    Callback = function(v)
        st.favorite.names = v
    end
})

-- CACHE MUTATION
local cachedMutations
local function GetFishMutation()
    if cachedMutations then return cachedMutations end

    local list = {}
    for _, v in pairs(repl.Variants:GetChildren()) do
        table.insert(list, v.Name)
    end
    cachedMutations = list
    return list
end

Favorites:AddDropdown({
    Title = "Auto Favorite by Mutation",
    Multi = true,
    Options = GetFishMutation(),
    Default = st.favorite.mutations,
    Callback = function(v)
        st.favorite.mutations = v
    end
})

----------------------------------------------------------------
-- TOGGLE
----------------------------------------------------------------
Favorites:AddToggle({
    Title = "Auto Favorite",
    Content = "Automatically favorites fish",
    Default = false,
    Callback = function(state)
        st.favorite.auto = state

        task.spawn(function()
            while st.favorite.auto do
                AutoFavorite(
                    st.favorite.names,
                    st.favorite.rarities,
                    st.favorite.mutations
                )
                task.wait(2)
            end
        end)
    end
})

Favorites:AddButton({
    Title = "Unfavorite All",
    Callback = UnAutoFavoriteAll
})


local HideFeature = Tabs.Misc:AddSection("Hide Features")

HideFeature:AddToggle({
    Title = "Anti AFK",
    Content = "Prevents you from being kicked for idling",
    Default = true, -- ðŸ”¥ AUTO ON
    Callback = function(state)
        local VirtualUser = game:GetService("VirtualUser")

        if state then
            -- Hindari double connection
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end

            antiAfkConnection = player.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        else
            -- Matikan Anti AFK dengan benar
            if antiAfkConnection then
                antiAfkConnection:Disconnect()
                antiAfkConnection = nil
            end
        end
    end
})

--==================================================
-- HIDE NOTIFICATION (SAFE HOOK, LOAD ONCE)
--==================================================

pcall(function()
    if not mods.NotificationController then return end

    -- ðŸ”’ CEGAH DOUBLE HOOK
    if mods.NotificationController._AegisNotifHooked then return end
    mods.NotificationController._AegisNotifHooked = true

    -- SIMPAN ORIGINAL
    local OriginalNotif = mods.NotificationController.PlaySmallItemObtained
    mods.NotificationController._AegisOriginalNotif = OriginalNotif

    -- OVERRIDE
    mods.NotificationController.PlaySmallItemObtained = function(self, ...)
        if st.hide.notifications then
            return -- BLOCK NOTIFICATION
        end
        return OriginalNotif(self, ...)
    end
end)

--==================================================
-- GUI TOGGLE
--==================================================

HideFeature:AddToggle({
    Title = "Hide Notification",
    Content = "Hides fishing item notifications",
    Default = false,
    Callback = function(state)
        st.hide.notifications = state
    end
}, "HideNotification")


--==================================================
-- SKIP CUTSCENE (INIT HOOK - SAFE VERSION)
--==================================================

pcall(function()
    if mods.CutsceneController and not mods.CutsceneController._AegisHooked then
        mods.CutsceneController._AegisHooked = true

        -- SIMPAN ORIGINAL
        mods.CutsceneController._OriginalInit =
            mods.CutsceneController._OriginalInit
            or mods.CutsceneController.Init

        -- OVERRIDE INIT
        mods.CutsceneController.Init = function(self, ...)
            if st.hide.cutscenes then
                return -- block init
            end
            return mods.CutsceneController._OriginalInit(self, ...)
        end
    end
end)

--==================================================
-- GUI TOGGLE
--==================================================

HideFeature:AddToggle({
    Title = "Skip Cutscenes",
    Content = "Automatically skips fishing cutscenes",
    Default = false,
    Callback = function(state)
        st.hide.cutscenes = state
    end
}, "HideCutscenes")

--==================================================
-- DISABLE ANIMATIONS (SAFE HOOK, LOAD ONCE)
--==================================================

pcall(function()
    if not mods.AnimationController then return end

    -- ðŸ”’ ANTI DOUBLE HOOK
    if mods.AnimationController._AegisAnimHooked then return end
    mods.AnimationController._AegisAnimHooked = true

    -- SIMPAN ORIGINAL
    local OriginalAnim = mods.AnimationController.PlayAnimation
    mods.AnimationController._AegisOriginalAnim = OriginalAnim

    -- OVERRIDE
    mods.AnimationController.PlayAnimation = function(self, ...)
        if st.hide.animations then
            return -- BLOCK ANIMATION
        end
        return OriginalAnim(self, ...)
    end
end)

--==================================================
-- GUI TOGGLE
--==================================================

HideFeature:AddToggle({
    Title = "Disable Animations",
    Content = "Disables fishing animations",
    Default = false,
    Callback = function(state)
        st.hide.animations = state
    end
}, "HideAnimations")

--==================================================
-- DISABLE VFX / ROD EFFECT (SAFE HOOK, LOAD ONCE)
--==================================================

pcall(function()
    if not mods.VFX then return end

    -- ðŸ”’ ANTI DOUBLE HOOK
    if mods.VFX._AegisVFXHooked then return end
    mods.VFX._AegisVFXHooked = true

    -- SIMPAN ORIGINAL
    mods.VFX._AegisOriginalRenderAtPoint = mods.VFX.RenderAtPoint
    mods.VFX._AegisOriginalRenderInstance = mods.VFX.RenderInstance

    -- OVERRIDE RenderAtPoint
    mods.VFX.RenderAtPoint = function(self, ...)
        if st.hide.vfx then
            return -- BLOCK VFX
        end
        return mods.VFX._AegisOriginalRenderAtPoint(self, ...)
    end

    -- OVERRIDE RenderInstance
    mods.VFX.RenderInstance = function(self, ...)
        if st.hide.vfx then
            return -- BLOCK VFX
        end
        return mods.VFX._AegisOriginalRenderInstance(self, ...)
    end
end)

--==================================================
-- GUI TOGGLE
--==================================================

HideFeature:AddToggle({
    Title = "Disable Rod Effect",
    Content = "Hides the fishing rod bobber effect",
    Default = false,
    Callback = function(state)
        st.hide.vfx = state
    end
}, "HideVFX")

--//======================================================
--// FPS BOOST (REDUCE MAP / INVISIBLE)
--//======================================================

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Terrain = workspace:FindFirstChildOfClass("Terrain")

local FPS_BOOST_ACTIVE = false

-- CACHE ORIGINAL PROPERTIES (AGAR BISA RESTORE)
local CachedParts = {}
local CachedLighting = {}
local CachedTerrain = {}

--------------------------------------------------------
-- SAVE ORIGINAL STATE
--------------------------------------------------------
local function CachePart(part)
    if CachedParts[part] then return end

    CachedParts[part] = {
        Transparency = part.Transparency,
        Material = part.Material,
        CastShadow = part.CastShadow,
        CanCollide = part.CanCollide
    }
end

--------------------------------------------------------
-- APPLY FPS BOOST
--------------------------------------------------------
local function EnableFPSBoost()
    if FPS_BOOST_ACTIVE then return end
    FPS_BOOST_ACTIVE = true

    -- LIGHTING
    CachedLighting = {
        GlobalShadows = Lighting.GlobalShadows,
        FogEnd = Lighting.FogEnd,
        Brightness = Lighting.Brightness
    }

    Lighting.GlobalShadows = false
    Lighting.FogEnd = 9e9
    Lighting.Brightness = 1

    -- TERRAIN
    if Terrain then
        CachedTerrain = {
            WaterWaveSize = Terrain.WaterWaveSize,
            WaterWaveSpeed = Terrain.WaterWaveSpeed,
            WaterTransparency = Terrain.WaterTransparency,
            WaterReflectance = Terrain.WaterReflectance
        }

        Terrain.WaterWaveSize = 0.15
        Terrain.WaterWaveSpeed = 0.15
        Terrain.WaterTransparency = 1
        Terrain.WaterReflectance = 0.15
    end

    -- MAP OBJECTS
    for _, obj in ipairs(workspace:GetDescendants()) do
        if not FPS_BOOST_ACTIVE then break end

        -- BASEPART
        if obj:IsA("BasePart") then
            CachePart(obj)

            obj.Material = Enum.Material.SmoothPlastic
            obj.CastShadow = false

            -- Part besar â†’ invisible
            if obj.Size.Magnitude > 20 then
                obj.Transparency = 1
                obj.CanCollide = false
            end

        -- DECAL / TEXTURE
        elseif obj:IsA("Decal") or obj:IsA("Texture") then
            obj:Destroy()

        -- PARTICLE / EFFECT
        elseif obj:IsA("ParticleEmitter")
            or obj:IsA("Trail")
            or obj:IsA("Beam")
            or obj:IsA("Fire")
            or obj:IsA("Smoke")
            or obj:IsA("Sparkles")
        then
            obj.Enabled = false

        -- MESH DETAIL
        elseif obj:IsA("SpecialMesh") then
            obj:Destroy()
        end
    end
end

--------------------------------------------------------
-- DISABLE FPS BOOST (RESTORE)
--------------------------------------------------------
local function DisableFPSBoost()
    FPS_BOOST_ACTIVE = false

    -- RESTORE PARTS
    for part, data in pairs(CachedParts) do
        if part and part.Parent then
            part.Transparency = data.Transparency
            part.Material = data.Material
            part.CastShadow = data.CastShadow
            part.CanCollide = data.CanCollide
        end
    end
    CachedParts = {}

    -- RESTORE LIGHTING
    for k, v in pairs(CachedLighting) do
        Lighting[k] = v
    end
    CachedLighting = {}

    -- RESTORE TERRAIN
    if Terrain and CachedTerrain then
        for k, v in pairs(CachedTerrain) do
            Terrain[k] = v
        end
    end
    CachedTerrain = {}
end

--------------------------------------------------------
-- GUI TOGGLE
--------------------------------------------------------

local MiscSection = Tabs.Misc:AddSection("Performance")

MiscSection:AddToggle({
    Title = "FPS Boost (Reduce Map)",
    Content = "Hide map & effects to increase FPS",
    Default = false,
    Callback = function(state)
        if state then
            EnableFPSBoost()
        else
            DisableFPSBoost()
        end
    end
})


MiscSection:AddToggle({
    Title = "Disable 3D Rendering",
    Content = "Disables 3D rendering to reduce GPU usage",
    Default = false,
    Callback = function(state)
        setfpscap(240)
        if RunService.Set3dRenderingEnabled then
            RunService:Set3dRenderingEnabled(not state)
        end
    end
})

--==================================================
-- AEGISHUB AUTO REJOIN SAME SERVER + KEEP SCRIPT
--==================================================

-- SERVICES
local Players          = game:GetService("Players")
local TeleportService  = game:GetService("TeleportService")
local HttpService      = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer

--==================================================
-- GLOBAL FLAGS (ANTI DUPLICATE)
--==================================================
_G.__AEGIS_REJOIN_RUNNING = _G.__AEGIS_REJOIN_RUNNING or false
_G.__AEGIS_QUEUED         = _G.__AEGIS_QUEUED or false

--==================================================
-- CONFIG
--==================================================
local AutoServer = {
    Enabled  = false,
    AutoKeep = true,
    PlaceId  = game.PlaceId,
    JobId    = game.JobId
}

local SAVE_FILE = "AegisHub_Server.json"

--==================================================
-- SAVE CURRENT SERVER
--==================================================
local function SaveCurrentServer()
    AutoServer.PlaceId = game.PlaceId
    AutoServer.JobId   = game.JobId

    if writefile then
        pcall(function()
            writefile(SAVE_FILE, HttpService:JSONEncode({
                PlaceId = AutoServer.PlaceId,
                JobId   = AutoServer.JobId
            }))
        end)
    end
end

-- AUTO SAVE ON LOAD
SaveCurrentServer()

--==================================================
-- LOAD SAVED SERVER
--==================================================
local function LoadSavedServer()
    if not (readfile and isfile) then return end
    if not isfile(SAVE_FILE) then return end

    local ok, data = pcall(function()
        return HttpService:JSONDecode(readfile(SAVE_FILE))
    end)

    if ok and data and data.PlaceId and data.JobId then
        AutoServer.PlaceId = data.PlaceId
        AutoServer.JobId   = data.JobId
    end
end

LoadSavedServer()

--==================================================
-- REJOIN SAME SERVER (SAFE)
--==================================================
local function RejoinSameServer()
    if not AutoServer.Enabled then return end
    if not AutoServer.PlaceId or not AutoServer.JobId or AutoServer.JobId == "" then
        return
    end

    if _G.__AEGIS_REJOIN_RUNNING then return end
    _G.__AEGIS_REJOIN_RUNNING = true

    task.delay(1, function()
        pcall(function()
            TeleportService:TeleportToPlaceInstance(
                AutoServer.PlaceId,
                AutoServer.JobId,
                LocalPlayer
            )
        end)
    end)
end

--==================================================
-- TELEPORT FAIL HANDLER
--==================================================
LocalPlayer.OnTeleport:Connect(function(state)
    if state == Enum.TeleportState.Failed then
        _G.__AEGIS_REJOIN_RUNNING = false
        task.wait(2)
        RejoinSameServer()
    end
end)

--==================================================
-- AUTO KEEP AEGISHUB (ANTI DUPLICATE LOAD)
--==================================================
if queue_on_teleport and AutoServer.AutoKeep and not _G.__AEGIS_QUEUED then
    _G.__AEGIS_QUEUED = true

    queue_on_teleport([[
        repeat task.wait() until game:IsLoaded()
        if not _G.__AEGIS_LOADED then
            _G.__AEGIS_LOADED = true
            loadstring(game:HttpGet(
                "https://raw.githubusercontent.com/rendy45kz/vir/refs/heads/main/Fishitv5"
            ))()
        end
    ]])
end

--==================================================
-- GUI (SIMPLE & MOBILE FRIENDLY)
--==================================================

local ServerSection = Tabs.Misc:AddSection("Server Control")

ServerSection:AddToggle({
    Title = "Auto Rejoin Same Server",
    Default = false,
    Callback = function(v)
        AutoServer.Enabled = v
    end
})

ServerSection:AddToggle({
    Title = "Auto Keep AegisHub",
    Default = true,
    Callback = function(v)
        AutoServer.AutoKeep = v
    end
})

ServerSection:AddButton({
    Title = "Save Current Server",
    Callback = function()
        SaveCurrentServer()
    end
})

ServerSection:AddButton({
    Title = "Rejoin Saved Server",
    Callback = function()
        RejoinSameServer()
    end
})

local shop = Tabs.Shop:AddSection("Merchant Shop")

local ShopMerchant = shop:AddParagraph({
  Title = "Merchant Stock Panel",
  Content = [[
- N/A
- N/A
- N/A

Next Refresh: 00H, 00M, 00S
  ]]
})

local function GetPanelItem(Panel)
  local Items = {}
  for _, Obj in ipairs(Panel:GetChildren()) do
    if Obj.Name == "Template" then
      local ItemName = Obj:FindFirstChild("Frame")
      if ItemName and ItemName:FindFirstChild("ItemName") then
        table.insert(Items, ItemName.ItemName.Text)
      end
    end
  end
  return Items
end

task.spawn(function()
  while task.wait(3) do
    local items = GetPanelItem(gui.ItemsFrame)
    ShopMerchant:SetContent(
      string.format([[
- %s
- %s
- %s

%s
      ]],
        items[1] or "N/A",
        items[2] or "N/A",
        items[3] or "N/A",
        gui.RefreshMerchant.Text
      ))
  end
end)

shop:AddButton({
  Title = "Open / Close Merchant",
  Content = "Opens or closes the merchant shop panel",
  Callback = function()
    gui.Merchant.Enabled = not gui.Merchant.Enabled
  end
})

local WeatherShop = Tabs.Shop:AddSection("Buy Weather")


WeatherShop:AddDropdown({
  Title = "Select Weather",
  Content = "Select a weather to change to",
  Multi = true,
  Options = {
    "Wind (10,000)",
    "Cloudy (20,000)",
    "Snow (15,000)",
    "Storm (35,000)",
    "Radiant (50,000)",
    "Shark Hunt (300,000)"
  },
  Default = {},
  Callback = function(value)
    st.shop.weather = value
  end
})

WeatherShop:AddToggle({
  Title = "Auto Buy Weather",
  Content = "Automatically buys selected weather effects",
  Default = false,
  Callback = function(state)
    st.shop.autoWeather = state

    task.spawn(function()
      while st.shop.autoWeather and st.shop.weather do
        for _, weather in ipairs(st.shop.weather) do
          api.Functions.BuyWeather:InvokeServer(weather:match("^(.-) %("))
        end
        task.wait(5)
      end
    end)
  end
})

local Islands= Tabs.Teleport:AddSection("Teleports Islands")

local TeleportLocations = {
    ["Fishermand Island"] = CFrame.new(251.970, 3.262, 2972.211) * CFrame.Angles(-3.141593, -1.257929, -3.141593),
	["Crater Island"] = CFrame.new(1072.845, 5.034, 5112.388) * CFrame.Angles(-0.000000, 1.229756, -0.000000),
	["Ancient Jungle"] = CFrame.new(1433.173, 6.625, -782.708) * CFrame.Angles(-0.000000, -0.360566, -0.000000),
	["Kohana"] = CFrame.new(-655.889, 17.250, 483.854) * CFrame.Angles(-0.000000, -1.567192, -0.000000),
	["Volcano"] = CFrame.new(-560.156, 17.091, 110.184) * CFrame.Angles(-0.000000, -0.530737, -0.000000),
	["Sisyphus Statue"] = CFrame.new(-3779.833, -135.074, -971.949) * CFrame.Angles(-3.141593, -1.297434, -3.141593),
	["Tropical Grove"] = CFrame.new(-2033.356, 6.268, 3679.782) * CFrame.Angles(-3.141593, 0.767602, -3.141593),
	["Treasure Room"] = CFrame.new(-3649.771, -268.340, -1666.103) * CFrame.Angles(-3.141593, -1.352865, -3.141593),
	["Sacred Temple"] = CFrame.new(1476.163, -22.125, -675.394) * CFrame.Angles(-0.000000, -1.515740, -0.000000),
	["Coral Reefs"] = CFrame.new(-3132.816, 3.354, 2129.545) * CFrame.Angles(-0.000000, -0.597924, -0.000000),
	["Weather Machine"] = CFrame.new(-1515.702, 2.875, 1912.361) * CFrame.Angles(-3.141593, -0.177870, -3.141593),
	["Esoteric Dephts"] = CFrame.new(3204.603, -1302.855, 1410.619) * CFrame.Angles(-0.000000, 0.454337, -0.000000),
	["Ancient Ruin"] = CFrame.new(6099.980, -585.924, 4682.759) * CFrame.Angles(3.141535, 1.569459, -3.141535),
	["Underground Cellar"] = CFrame.new(2135.955, -91.199, -697.068) * CFrame.Angles(-0.000000, -0.098867, 0.000000),
	["Pirate Cove"] = CFrame.new(3399.40234375, 4.191970348358154, 3478.972412109375,0.2146824449300766, -2.6497572136463533e-8, -0.9766839146614075,-6.210501890535625e-9, 1, -2.8495255932625697e-8,0.9766839146614075, 1.2183128283993483e-8, 0.2146824449300766),
    ["Pirate Treasure Room"] = CFrame.new(3357.815673828125,-300.98785400390627,3054.89306640625,-0.37050673365592959,-4.5237129597808237e-8,0.9288297891616821,-2.0744495898838978e-8,1,4.04284570265645e-8,-0.9288297891616821,-4.289090416165209e-9,-0.37050673365592959)
}

local function GetNameTeleport()
  local Names = {}
  for Key,_ in pairs(TeleportLocations) do table.insert(Names, Key) end
  return Names
end

Islands:AddDropdown({
  Title = "Select Island",
  Content = "Select an island to teleport to",
  Options = GetNameTeleport(),
  Default = nil,
  Callback = function(value)
    st.teleport.island = value
  end
})

Islands:AddButton({
  Title = "Teleport",
  Content = "Teleports you to the selected island",
  Callback = function()
    local loc = TeleportLocations[st.teleport.island]
    if not loc then return end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
      hrp.CFrame = loc
    end
  end
})



local Save = Tabs.Automation:AddSection("Save position Features")
 
function SavePosition(cf)
  local data = { cf:GetComponents() }
  writefile(PositionFile, svc.HttpService:JSONEncode(data))
end
 
function LoadPosition()
  if isfile(PositionFile) then
    local success, data = pcall(function()
      return svc.HttpService:JSONDecode(readfile(PositionFile))
    end)
    if success and typeof(data) == "table" then
      return CFrame.new(unpack(data))
    end
  end
  return nil
end
 
function TeleportLastPos(char)
  task.spawn(function()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local last = LoadPosition()
 
    if last then
      task.wait(2)
      hrp.CFrame = last
    end
  end)
end
 
player.CharacterAdded:Connect(TeleportLastPos)
if player.Character then
  TeleportLastPos(player.Character)
end
 
Save:AddButton({
  Title = "Save Position",
  Callback = function()
      local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
      SavePosition(hrp.CFrame)
      sirenx("Position saved successfully!")
    end
  end,
  SubTitle = "Reset Position",
  SubCallback = function()
    if isfile(PositionFile) then
      delfile(PositionFile)
    end
    sirenx("Last position has been reset.")
  end
})

local Events = Tabs.Teleport:AddSection("Teleports Events")

--==================================================
-- CONFIG
--==================================================
local eventsList = {
    "Shark Hunt",
    "Ghost Shark Hunt",
    "Worm Hunt",
    "Temporary event",
    "Ghost Worm",
    "Black Hole",
    "Megalodon Hunt"
}

local LocalPlayer = game:GetService("Players").LocalPlayer

--==================================================
-- STATE
--==================================================
local autoEventTargetName = nil
local autoEventTeleportState = false
local autoEventTeleportThread = nil

local lastLocation = nil
local currentEventModel = nil
local lastEventPosition = nil

--==================================================
-- SAVE / RETURN POSITION
--==================================================
local function SaveLastLocation()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    lastLocation = hrp.CFrame
    return true
end

local function ReturnToLastLocation()
    if not lastLocation then return end
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = lastLocation
    end
end

--==================================================
-- FIND EVENT MODEL
--==================================================
local function FindTargetEvent()
    if not autoEventTargetName then return nil end

    local searchName = autoEventTargetName
    if searchName == "Temporary event" then
        searchName = "Black Hole"
    end

    local props = workspace:FindFirstChild("Props")
    if not props then return nil end

    if searchName == "Worm Hunt" then
        return props:FindFirstChild("Model")
    end

    return props:FindFirstChild(searchName)
end

--==================================================
-- TELEPORT
--==================================================
local function TeleportToEvent(eventModel)
    if not eventModel then return false end

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    local pos = eventModel:GetPivot().Position
    hrp.CFrame = CFrame.new(pos + Vector3.new(0, 18, 0))

    currentEventModel = eventModel
    lastEventPosition = pos
    return true
end

--==================================================
-- FOLLOW EVENT
--==================================================
local function FollowEvent()
    if not currentEventModel or not currentEventModel.Parent then
        currentEventModel = nil
        lastEventPosition = nil
        return
    end

    local pos = currentEventModel:GetPivot().Position
    if not lastEventPosition then
        lastEventPosition = pos
        return
    end

    if (pos - lastEventPosition).Magnitude > 6 then
        TeleportToEvent(currentEventModel)
    end
end

--==================================================
-- MAIN LOOP
--==================================================
local function StartAutoEventLoop()
    if autoEventTeleportThread then
        task.cancel(autoEventTeleportThread)
        autoEventTeleportThread = nil
    end

    autoEventTeleportThread = task.spawn(function()
        while autoEventTeleportState do
            if not currentEventModel then
                local found = FindTargetEvent()
                if found then
                    TeleportToEvent(found)
                    task.wait(2)
                else
                    task.wait(5)
                end
            else
                FollowEvent()
                task.wait(1)
            end
        end
    end)
end

--==================================================
-- GUI
--==================================================
Events:AddDropdown({
    Title = "Select Target Event",
    Content = "Choose event to auto teleport",
    Options = eventsList,
    Callback = function(value)
        autoEventTargetName = value
        currentEventModel = nil
        lastEventPosition = nil
    end
})

Events:AddToggle({
    Title = "Auto Teleport Event",
    Content = "Teleport & follow selected event",
    Default = false,
    Callback = function(state)
        if state and not autoEventTargetName then
            sirenx("Select event first!")
            return
        end

        autoEventTeleportState = state

        if state then
            SaveLastLocation()
            EnableWalkOnWater()
            StartAutoEventLoop()
            sirenx("Auto Event Teleport ON")
        else
            if autoEventTeleportThread then
                task.cancel(autoEventTeleportThread)
                autoEventTeleportThread = nil
            end

            DisableWalkOnWater()
            ReturnToLastLocation()

            currentEventModel = nil
            lastEventPosition = nil

            sirenx("Auto Event Teleport OFF")
        end
    end
})

--==================================================
-- CHARACTER SAFETY
--==================================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if autoEventTeleportState then
        EnableWalkOnWater()
    end
end)

LocalPlayer.CharacterRemoving:Connect(function()
    autoEventTeleportState = false

    if autoEventTeleportThread then
        task.cancel(autoEventTeleportThread)
        autoEventTeleportThread = nil
    end

    DisableWalkOnWater()
end)


local Plyr = Tabs.Teleport:AddSection("Teleports Player")

local function GetPlayerNames()
  local Names = {}
  for _, Plr in pairs(svc.Players:GetPlayers()) do
    if Plr ~= player then
      table.insert(Names, Plr.Name)
    end
  end
  return Names
end

local PlayerList = Plyr:AddDropdown({
  Title = "Select Player",
  Content = "Select a player to teleport to",
  Options = GetPlayerNames(),
  Default = nil,
  Callback = function(value)
    st.teleport.player = value
  end
})

Plyr:AddButton({
  Title = "Refresh Player List",
  Callback = function()
    PlayerList:SetValues(GetPlayerNames(), st.teleport.player)
  end,
  SubTitle = "Go to Player",
  SubCallback = function()
    TargetPlayer = svc.Players:FindFirstChild(st.teleport.player)
    if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("HumanoidRootPart") then
      st.char:PivotTo(TargetPlayer.Character:GetPivot())
    end
  end
})

--//======================================================
--// AUTO ADMIN EVENT (GUI MATCH)
--//======================================================

local player = game:GetService("Players").LocalPlayer

local AdminEventSection = Tabs.Automation:AddSection("Auto Admin Event")

-- STATUS PARAGRAPH
local countdownParagraph = AdminEventSection:AddParagraph({
    Title = "Ancient Lochness Monster",
    Content = "Waiting for event..."
})

-- STATE
local autoEventEnabled = false
local farmPosition = nil

-- GET COUNTDOWN LABEL
local function getCountdownLabel()
    local ok, label = pcall(function()
        return workspace["!!! DEPENDENCIES"]["Event Tracker"].Main.Gui.Content.Items.Countdown.Label
    end)
    return ok and label or nil
end

-- TELEPORT POS
local LOCHNESS_POS = CFrame.new(6063, -586, 4715)

local function goToEvent()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = LOCHNESS_POS
    end
end

local function returnToFarm()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if hrp and farmPosition then
        hrp.CFrame = farmPosition
    end
end

-- TOGGLE AUTO EVENT
AdminEventSection:AddToggle({
    Title = "Auto Lochness Event",
    Default = false,
    Callback = function(state)
        autoEventEnabled = state

        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if state then
            farmPosition = hrp.CFrame
        else
            returnToFarm()
        end
    end
})

-- COUNTDOWN LOOP (ALWAYS RUN)
task.spawn(function()
    local label = getCountdownLabel()

    while true do
        task.wait(1)

        if not label or not label.Parent then
            label = getCountdownLabel()
        end

        local text = label and label.Text or ""

        if text == "" then
            countdownParagraph:SetContent("Waiting for countdown...")
        else
            countdownParagraph:SetContent("Timer: " .. text)
        end

        if autoEventEnabled and text ~= "" then
            local h, m, s = text:match("(%d+)H%s*(%d+)M%s*(%d+)S")
            h, m, s = tonumber(h), tonumber(m), tonumber(s)

            if h == 3 and m == 59 and s == 59 then
                goToEvent()
            elseif h == 3 and m == 49 and s == 59 then
                returnToFarm()
            end
        end
    end
end)

--//======================================================
--// AUTO TOTEM (1 HOUR INTERVAL - ADMIN EVENT PATTERN)
--//======================================================

local player = game:GetService("Players").LocalPlayer
local RepStorage = game:GetService("ReplicatedStorage")

local AutoTotem = Tabs.Automation:AddSection("Auto Totem")

----------------------------------------------------------------
-- REMOTES
----------------------------------------------------------------
local RPath = {"Packages", "_Index", "sleitnick_net@0.2.0", "net"}

local function GetRemote(path, name)
    local cur = RepStorage
    for _, p in ipairs(path) do
        cur = cur:WaitForChild(p, 2)
        if not cur then return nil end
    end
    return cur:FindFirstChild(name)
end

local RE_SpawnTotem = GetRemote(RPath, "RE/SpawnTotem")
local RE_EquipToolFromHotbar = GetRemote(RPath, "RE/EquipToolFromHotbar")

----------------------------------------------------------------
-- DATA
----------------------------------------------------------------
local TOTEM_DATA = {
    ["Luck Totem"]     = {Id = 1},
    ["Mutation Totem"] = {Id = 2},
    ["Shiny Totem"]    = {Id = 3},
}

----------------------------------------------------------------
-- STATE
----------------------------------------------------------------
local autoTotemEnabled = false
local selectedTotem = "Luck Totem"
local nextSpawnTime = 0
local SPAWN_INTERVAL = 3600 -- 1 JAM

----------------------------------------------------------------
-- STATUS PARAGRAPH (AMAN)
----------------------------------------------------------------
local statusParagraph = AutoTotem:AddParagraph({
    Title = "Auto Totem Status",
    Content = "Inactive"
})

----------------------------------------------------------------
-- REPLION INVENTORY
----------------------------------------------------------------
local ReplionClient
local CachedData

local function GetReplion()
    if not ReplionClient then
        local pkg = RepStorage:WaitForChild("Packages", 5)
        local mod = pkg and pkg:FindFirstChild("Replion")
        if not mod then return nil end

        local ok, m = pcall(require, mod)
        if ok and m.Client then
            ReplionClient = m.Client
        end
    end

    if not CachedData and ReplionClient then
        local ok, d = pcall(function()
            return ReplionClient:WaitReplion("Data", 5)
        end)
        if ok then CachedData = d end
    end

    return CachedData
end

local function GetTotemUUID(name)
    local repl = GetReplion()
    if not repl then return nil end

    local ok, inv = pcall(function()
        return repl:Get("Inventory")
    end)
    if not ok or not inv or not inv.Totems then return nil end

    for _, t in ipairs(inv.Totems) do
        if tonumber(t.Id) == TOTEM_DATA[name].Id and (t.Count or 1) > 0 then
            return t.UUID
        end
    end
end

----------------------------------------------------------------
-- AUTO TOTEM LOOP (ADMIN EVENT STYLE)
----------------------------------------------------------------
task.spawn(function()
    while true do
        task.wait(1)

        if not autoTotemEnabled then
            statusParagraph:SetContent("Inactive")
            continue
        end

        local now = os.time()
        local left = nextSpawnTime - now

        if left > 0 then
            local m = math.floor(left / 60)
            local s = left % 60
            statusParagraph:SetContent(
                string.format("Next Spawn: %02d:%02d", m, s)
            )
        else
            local uuid = GetTotemUUID(selectedTotem)

            if not uuid then
                statusParagraph:SetContent("Totem Out of Stock")
                autoTotemEnabled = false
                sirenx("Totem out of stock: " .. selectedTotem)
                continue
            end

            task.wait(0.5)

            -- SPAWN TOTEM
            pcall(function()
                RE_SpawnTotem:FireServer(uuid)
            end)

            -- AUTO EQUIP ROD (AMAN)
            task.spawn(function()
                for i = 1, 3 do
                    task.wait(0.5)
                    pcall(function()
                        RE_EquipToolFromHotbar:FireServer(1)
                    end)
                end
            end)

            nextSpawnTime = now + SPAWN_INTERVAL
            statusParagraph:SetContent("Totem Spawned")
            sirenx("Totem spawned: " .. selectedTotem)
        end
    end
end)

----------------------------------------------------------------
-- GUI
----------------------------------------------------------------
AutoTotem:AddDropdown({
    Title = "Select Totem",
    Options = {"Luck Totem", "Mutation Totem", "Shiny Totem"},
    Default = "Luck Totem",
    Callback = function(v)
        selectedTotem = v
        nextSpawnTime = 0
        sirenx("Selected Totem: " .. v)
    end
})

AutoTotem:AddToggle({
    Title = "Enable Auto Totem",
    Content = "Spawn totem every 1 hour",
    Default = false,
    Callback = function(state)
        autoTotemEnabled = state
        nextSpawnTime = 0
    end
})

AutoTotem:AddButton({
    Title = "Spawn Totem Now",
    Content = "Manual spawn",
    Callback = function()
        local uuid = GetTotemUUID(selectedTotem)
        if not uuid then
            sirenx("No totem in inventory")
            return
        end

        pcall(function()
            RE_SpawnTotem:FireServer(uuid)
        end)

        -- Auto equip rod
        task.spawn(function()
            for i = 1, 3 do
                task.wait(0.2)
                pcall(function()
                    RE_EquipToolFromHotbar:FireServer(1)
                end)
            end
        end)
    end
})

--[[
--//======================================================
--// AUTO CHRISTMAS CAVE (WIB) - FULL FIX
--//======================================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

--======================================================
-- CONFIG
--======================================================

-- POSISI CHRISTMAS CAVE
local CHRISTMAS_CAVE_POS =
    CFrame.new(541.647, -580.581, 8902.609)
    * CFrame.Angles(0, -1.728958, 0)

-- JADWAL:
-- MULAI 03:00 WIB
-- TIAP 3 JAM
-- DURASI 90 MENIT
local ChristmasSchedule = {
    "03:00","04:30",
    "06:00","07:30",
    "09:00","10:30",
    "12:00","13:30",
    "15:00","16:30",
    "18:00","19:30",
    "21:00","22:30",
    "00:00","01:30"
}

--======================================================
-- STATE
--======================================================

local autoChristmas = false
local loopThread = nil
local lastCFrame = nil
local inCave = false

--======================================================
-- UI
--======================================================

local statusParagraph = AdminEventSection:AddParagraph({
    Title = "Christmas Cave Status",
    Content = "Inactive"
})

--======================================================
-- TIME HELPERS (WIB)
--======================================================

local function getWIB()
    local t = os.date("!*t") -- UTC
    local h = (t.hour + 7) % 24
    return h, t.min, t.sec
end

local function timeToSec(str)
    local h, m = str:match("(%d+):(%d+)")
    return tonumber(h) * 3600 + tonumber(m) * 60
end

--======================================================
-- TELEPORT FUNCTIONS
--======================================================

local function getHRP()
    local char = player.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function goCave()
    local hrp = getHRP()
    if not hrp then return end

    if not inCave then
        lastCFrame = hrp.CFrame
    end

    hrp.CFrame = CHRISTMAS_CAVE_POS
    inCave = true
end

local function returnBack()
    local hrp = getHRP()
    if not hrp or not lastCFrame then return end

    hrp.CFrame = lastCFrame
    inCave = false
end

--======================================================
-- MAIN LOOP
--======================================================

local function ChristmasLoop()
    while autoChristmas do
        local h, m, s = getWIB()
        local nowSec = h * 3600 + m * 60 + s

        local insideSchedule = false

        for i = 1, #ChristmasSchedule, 2 do
            local startSec = timeToSec(ChristmasSchedule[i])
            local endSec   = timeToSec(ChristmasSchedule[i + 1])

            -- HANDLE LEWAT TENGAH MALAM
            if startSec > endSec then
                if nowSec >= startSec or nowSec <= endSec then
                    insideSchedule = true
                    break
                end
            else
                if nowSec >= startSec and nowSec <= endSec then
                    insideSchedule = true
                    break
                end
            end
        end

        if insideSchedule then
            if not inCave then
                goCave()
            end
            statusParagraph:SetContent(
                string.format("ACTIVE | WIB %02d:%02d:%02d", h, m, s)
            )
        else
            if inCave then
                returnBack()
            end
            statusParagraph:SetContent(
                string.format("Waiting | WIB %02d:%02d:%02d", h, m, s)
            )
        end

        task.wait(1)
    end

    -- SAFETY CLEANUP
    if inCave then
        returnBack()
    end

    statusParagraph:SetContent("Inactive")
end

--======================================================
-- TOGGLE
--======================================================

AdminEventSection:AddToggle({
    Title = "Auto Christmas Cave (WIB)",
    Content = "Automatically teleports to Christmas Cave based on WIB schedule",
    Default = false,
    Callback = function(state)
        autoChristmas = state

        if loopThread then
            task.cancel(loopThread)
            loopThread = nil
        end

        if state then
            loopThread = task.spawn(ChristmasLoop)
        else
            if inCave then
                returnBack()
            end
        end
    end
})

--======================================================
-- BUTTONS
--======================================================

AdminEventSection:AddButton({
    Title = "Teleport Now",
    Content = "Force teleport to Christmas Cave",
    Callback = function()
        goCave()
    end
})

AdminEventSection:AddButton({
    Title = "Return to Position",
    Content = "Return to last position before cave",
    Callback = function()
        returnBack()
    end
})

--======================================================
-- CHARACTER RESPAWN SAFETY
--======================================================

player.CharacterAdded:Connect(function()
    task.wait(2)
    if autoChristmas then
        inCave = false
    end
end) ]]--
